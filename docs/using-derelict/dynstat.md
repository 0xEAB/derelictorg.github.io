## Bindings Defined

The bindings in Derelict are primarily _dynamic bindings_, as opposed to those in the [Deimos project] which are all _static bindings_. This page aims to clarify the difference between static and dynamic bindings. It is important when starting a new project to understand the implications of each and selecting the right type of binding in order to avoid unnecessary frustration.

### Terminology

Before getting to the differences between the two types of bindings, it would help to understand some relevant terminology as used throughout this documentation. This is especially important since the words _static_ and _dynamic_ are used in multiple contexts. Understanding the terminology will help to avoid confusion in online discussions or when asking for help.

* **binding** -- an interface to a library in one language that enables the library to be used in another language. Typically, the binding provides a one-to-one mapping to the original interface. For example, all of the types and functions declared in the Derelict packages correspond exactly to the types and functions in the original C libraries, except in cases where the original API uses a variable or type name that is a keyword in D. Bindings are sometimes mistakenly referred to as _wrappers_.
* **wrapper** -- a higher-level interface to a library. Wrappers are typically written in the same language as the underlying API, either that of the original library or a binding to that library. For example, a wrapper for OpenGL written in D would be written on top of an OpenGL binding. Wrappers typically provide functionality that makes using the library more convenient. For example, an OpenGL wrapper for D might use classes to represent OpenGL objects such as textures and shaders, encapsulating commonly grouped function calls into single class methods. None of the packages in Derelict are wrappers. They are all bindings. However, D wrappers can be made that use Derelict packages to interface with the C libraries. For example, an OpenGL wrapper can be written on top of [DerelictGL3].
* **static linking** -- occurs at compile time when building an exectuable with a statically compiled language such as C, C++ or D. All of the object files generated by the compiler are fed to the _linker_, which _links_ them together, along with any _static libraries_ that the application may need, in order to generate the final executable. The static library is an archive containing precompiled object files that are all combined into the final executable. Static libraries on Windows tend to have the .lib file extension; static libraries on Posix systems tend to have .a extensions. Since the objects in the static library become a part of the executable, they add to its file size. When new versions of a static library are released with bug fixes and improvements, all applications that use it must be recompiled so that the new objects can become part of the exectuable.
* **dynamic linking** -- as with static linking, this happens just after the compile step when buidling an executable with a statically compiled language such as C, C++ or D. However, instead of linking with a _static library_, the linker links with a _shared library_ directly or, usually on Windows systems, with an _import library_ (which, confusingly, have the .lib file extension like static libraries). Shared libraries are referred to as _dynamic link libraries_ on Windows (usually with the .dll extension) and as _shared objects_ on most Posix systems (with a .so extension). In addition to shared object, one can also find _dynamic libraries_ with the .dylib extension on Mac OS X. Though the names and file formats may be different, all shared libraries are fundamentally the same. Like static libraries, shared libraries are archive files containing precompiled objects. The difference is that they _are not_ combined into the final executable. Instead, information is inserted by the linker that the OS uses at run time to load the shared library into memory when the application starts. This allows a single library to be shared by multiple applications, which makes executables smaller and allows all applications using the same library to benefit when the library is updated with bug fixes or improvements. It also means that the shared library must be available on the end-user's system in a location on the system library search path.
* **dynamic loading** -- like _dynamic linking_, this uses _shared libraries_, but there is no link step after compilation. Instead, the shared libraries are loaded manually by the executable at run time. To be clear, _dynamic linking_ has a link-time dependency when the final executable is generated, then the OS will load the relevant shared libraries at run time; _dynamic loading_ has no link-time dependency and the executable can be generated by the linker without the shared libraries being present on the system. In order for dynamic loading to work, the program must make use of OS-specific APIs (or third-party wrappers) to load the shared libraries into the process memory space and to assign the symbols in the library to pointers declared for that purpose. In other words, the shared library is loaded manually rather than automatically. The shared library must also be available on the end-user's system in a location that is on the system library search path. Aside from eliminating link-time dependencies, another benefit of this approach is that it allows different implementations of a shared library's interface to be easily swapped at run time.

### Dynamic vs. Static

The primary difference between a dynamic and a static binding is that the former has no link-time dependency on the library to which it binds. Both types require that the bindings themselves be either linked with the executable or compiled along with the application. However, static bindings have the additional requirement that the bound library must be either statically linked (with a static library) or dynamically linked (with a shared library) when the executable is generated. Dynamic bindings make use of dynamic loading to load shared libraries at run time and, therefore, have no link-time dependencies beyond the binding itself. This is explained below.

#### Static Bindings

The source code for static bindings in D, like those found in the [Deimos project], tends to look very similar to the C or C++ headers for the C library to which they bind. Functions can be declared as normal, simply with no implementation. For example:

```D
extern(C) void SomeFunction(int);
```

Given a C library, **MyLib**, which exposes the function SomeFunction declared above, the user of the D binding for **MyLib** must either statically link with the **MyLib** static library (**MyLib.lib** on Windows, **libMylib.a** elsewhere) or with the **MyLib** shared library (the import library **MyLib.lib** on Windows, or **libMyLib.so** elsewhere). Additionally, the user must also link with the **MyLib** binding itself, most often as a static library, if it contains anything more than delcarations.

On Windows, there can be some effort required to link with the C library. At issue is the object file format used by different linkers. For example, when compiling on 32-bit Windows, DMD uses the OPTLINK linker by default, which only understands the [OMF object format]. This is the format that was commonly used on Windows back in the DOS days. Modern Windows compilers and linkers more typically use [COFF] instead. As such, most precompiled static and shared libraries available online are in COFF format. To be used with the default 32-bit DMD toolchain, they must either be converted to OMF using a conversion tool, or the source for the library must be compiled with a compiler that generates OMF files, such as the [Digital Mars C & C++ Compiler (DMC)][1]. However, when compiling with DMD in 64-bit mode, DMD makes use of the Visual C++ toolchain. In this case, the VS linker understands the COFF format, so the conversion step is not necessary. Detailing the object file formats used by every D compiler is beyond the scope of this documentation. It's up to the user to know the output of the tools being used.

Different people may see different benefits and drawbacks to using static bindings. One of the biggest benefits, perhaps, is that a static binding offers a choice between statically linking with and dynamically linking with the C library. However, no matter the choice mad, there is no way to escape the link-time dependency imposed by a static binding.

#### Dynamic Bindings

Not only are dynamic bindings used differently than static bindings, they are implemented differently. Normal function prototypes do not work with dynamic bindings because of the fact that such bindings make use of <em>dynamic loading</em>. All of the functions in the bound library must be declared in the binding as function pointers. The MyLib example above converted to a dynamic binding format in D might look something like this:

```D
extern(C) alias p_SomeFunction = void function(int);
p_SomeFunction SomeFunction;
```

When an application using the MyLib dynamic binding is compiled, there is no link-time dependency beyond the binding itself. At run time, the dynamic binding will make a call into the OS API to load the MyLib shared library into the application's memory space. After that, it will again call into the OS API to fetch the address of the SomeFunction implementation and assign it to the SomeFunction variable declared above. From that point on, SomeFunction is ready to use.

Aside from eliminating the link-time dependency on the bound library, dynamic bindings give the user control over the case when the shared library fails to load, typically because it is missing from the user's system, is an incompatible version, or is otherwise corrupt. When using a static binding with dynamic linking, the OS itself reports an error in these cases, which may not always be desirable. Because a dynamic binding uses dynamic loading, it  is possible for the application to detect such errors and react in a manner appropriate for the application, such as displaying a message box with a link to a tech support page.

### Conclusion

The information above is intended to shed light on the difference between static and dynamic bindings. Generally, neither type of binding is "better" than the other. For most applications, it probably doesn't matter which type is used as long as the application programmer is comfortable with the concepts of compiling, linking, and loading. The pros and cons of each approach can take on different weights in different contexts, but debating or explaining such is beyond the scope of this documentation.


[Deimos Project]: https://github.com/D-Programming-Deimos
[DerelictGL3]: https://github.com/DerelictOrg/DerelictGL3
[OMF object format]: http://en.wikipedia.org/wiki/Relocatable_Object_Module_Format
[COFF]: https://support.microsoft.com/en-us/kb/121460
[1]: http://www.digitalmars.com/features.html