{
    "docs": [
        {
            "location": "/",
            "text": "Derelict is a collection of dynamic bindings to C and C++ libraries for the D programming language. It enables users to access popular libraries such as OpenGL, SDL, Lua and more, easily and with little effort across several platforms. This set of documentation provides users with the necessary knowledge to get started with Derelict, including general information applicable to all packages in the collection and package-specific information for each package. It is recommended that new Derelict users read the general documentation first, followed by the specific documentation for packages they intend to use.\n\n\nAll Derelict packages make use of the same build and package management system, \nDUB\n, and a common foundation in the form of DerelictUtil. The sections of this documentation that are not package-specific outline the common steps required to configure a project to build and link with Derelict packages, as well as the common interface used to use the Derelict packages in code.\n\n\nWhile the steps to use most Derelict packages are identical, there are sometimes exceptions to the rule. Furthermore, each package has its own versioning scheme independent of the C or C++ library to which it binds. Because of this, before implementing Derelict in a project, it is advised to take the time to read the specific documentation for any packages the project makes use of. This will ensure the project is based on the version of the package appropriate to its requirements and any special steps the package requires can be understood.",
            "title": "Introduction"
        },
        {
            "location": "/support/",
            "text": "A forum used to be maintained specifically for Derelict discussion and support, but it was taken down as the result of a server move and never reopened. There are plans to open a new forum at some point in the future, but for now the best methods to find help with Derelict are, in no particular order:\n\n\n\n\nVist the IRC channel #D on freenode.net. A number of Derelict users are active there.\n\n\nEmail Mike Parker via \naldacron@gmail.com\n.\n\n\nUsers new to both D and Derelict might visit the \nD Newsgroups\n, specifically \ndigitalmars.D.learn\n, which can be accessed via Vladimir Panteleev's \nweb interface\n and a \nmailing list interface\n in addition to standard newsreaders. However, please be aware that this is a generic D newsgroup and not specifically a Derelict support forum. Mike usually checks the newgroups at least once a day, and other regular participants are familiar with Derelict, but there are no guarantees a question about Derelict will be answered promptly.",
            "title": "Support"
        },
        {
            "location": "/overview/",
            "text": "All of the packages in Derelict are \ndynamic bindings\n. Dynamic bindings may not be suitable for every application. Sometimes, \nstatic bindings\n may be more desirable. Before learning how to compile, link and run programs using Derelict, it is useful to understand the difference between the two types of bindings. The page \nAbout Bindings\n explains this along with other terminology used in this documentation that will be helpful when discussing Derelict with others.\n\n\nOnce the decision to use Derelict has been made, the next step is to decide how to manage the project. Derelict is designed to work out of the box with DUB, the build tool and package manager for D. When using Derelict, it is most convenient to use DUB to build and manage the entire application, but it is not required. As long as DUB is available to build the Derelict libraries, they can be used with any build tool or IDE. The page on \nCompiling and Linking\n explains the steps required for both cases. \n\n\nThe last part of this section deals with how to use Derelict at runtime. All Derelict packages have a basic common interface that allow the shared libraries to which they bind to be easily loaded. This is covered in pages on \nLoading Shared Libraries\n and \nLoad Failures\n. Some packages may provide additional features, such as the option to link with a startic C library (in which case no loading is needed), or may require additional steps after the library is loaded. For details, see the package-specific documentation.",
            "title": "Overview"
        },
        {
            "location": "/bindings/",
            "text": "The bindings in Derelict are primarily \ndynamic bindings\n, as opposed to those in the \nDeimos project\n which are all \nstatic bindings\n. This page aims to clarify the difference between the two types of bindings. It is important when starting a new project to understand the implications of each and to select the appropriate type in order to avoid unnecessary frustration.\n\n\nTerminology\n\n\nBefore getting to the differences between the two types of bindings, it would help to understand some relevant terminology as used throughout this documentation. This is especially important since the words \nstatic\n and \ndynamic\n are commonly used in multiple contexts. Understanding the terminology will help to avoid confusion in online discussions or when asking for help.\n\n\n\n\nbinding\n -- a direct interface to a library in one language that enables the library to be used in another language. Typically, the binding provides a one-to-one mapping to the original interface. For example, the names of all type and function declarations in the Derelict packages correspond exactly to those declared in the original C libraries, except in cases where the original API uses a variable or type name that is a keyword in D. Bindings are sometimes mistakenly referred to as \nwrappers\n.\n\n\nwrapper\n -- a higher-level interface to a library. Wrappers are typically written in the same language as the underlying API, either that of the original library or a binding to that library. For example, a wrapper for OpenGL written in D would be written on top of an OpenGL binding that is also written in D. Wrappers typically provide functionality that makes using the library more convenient. For example, an OpenGL wrapper for D might use classes to represent OpenGL objects such as textures and shaders, encapsulating commonly grouped function calls into single class methods. None of the packages in Derelict are wrappers. They are all bindings. However, D wrappers can be made that use Derelict packages to interface with the C libraries. For example, an OpenGL wrapper can be written on top of \nDerelictGL3\n.\n\n\nstatic linking\n -- occurs right after the compile step when building an exectuable with a statically compiled language such as C, C++ or D. All of the object files generated by the compiler are fed to a \nlinker\n, which \nlinks\n them together, along with any \nstatic libraries\n that the application may need, in order to generate the final executable. A static library is an archive containing precompiled object files that are all combined into the final executable. Static libraries on Windows tend to have the \n.lib\n file extension; static libraries on Posix systems tend to have \n.a\n extensions. Since the objects in a static library become a part of the executable, they add to its file size. When new versions of a static library are released with bug fixes and improvements, all applications that use it must be recompiled in order to benefit from them.\n\n\ndynamic linking\n -- as with static linking, this happens just after the compile step when building an executable with a statically compiled language such as C, C++ or D. However, instead of linking with a \nstatic library\n, the linker links with a \nshared library\n directly or, on Windows systems, with an \nimport library\n (which, confusingly, have the same \n.lib\n file extension as static libraries). Shared libraries are referred to as \ndynamic link libraries\n on Windows (usually with the \n.dll\n extension) and as \nshared objects\n on most Posix systems (with the \n.so\n extension). Along with shared object files, one can also find \ndynamic libraries\n with the \n.dylib\n extension on Mac OS X. Though the names and file formats may be different, all shared libraries are fundamentally the same. Like static libraries, shared libraries are archive files containing precompiled objects. The difference is that they \nare not\n combined into the final executable at link time. Instead, information for the system loader is inserted into the executable by the linker. The OS can use this information at run time to load the shared library into memory when the application starts. This allows a single library to be shared by multiple applications, which makes executables smaller and allows all applications using the same library to benefit when the library is updated with bug fixes or improvements, without the need to recompile any of them. It also means that the shared library must be available on the end-user's system in a location that resides on the system library search path.\n\n\ndynamic loading\n -- this is a means of using shared libraries without a link step after compilation. Instead, the shared libraries are loaded manually by the executable at run time. To be clear, dynamic linking has a link-time dependency when the final executable is generated and the OS will automatically load the relevant shared libraries at run time; \ndynamic loading\n has no link-time dependency and the executable can be generated by the linker without the shared libraries being present on the system. In order for dynamic loading to work, the program must make use of OS-specific APIs (or third-party wrappers) to load the shared libraries into the process memory space. Since the linker is not used to generate locations in memory for the shared library's symbols, the program must declare pointers to the symbols in the shared library that it wants to use and manually match them with the symbols in the shared library after loading it into memory. In other words, the shared library is loaded manually rather than automatically. The shared library must also be available on the end-user's system in a location that is on the system library search path, otherwise the system APIs will not be able to find it. Aside from eliminating link-time dependencies, this approach allows different implementations of a shared library's interface to be easily swapped at run time.\n\n\n\n\nDynamic vs. Static Bindings\n\n\nThe primary difference between a dynamic and a static binding is that the former has no link-time dependency on the library to which it binds. Both types require that the bindings themselves be either linked with the executable or compiled along with the application. However, static bindings have the additional requirement that the bound library must be either statically linked (with a static library) or dynamically linked (with a shared library) when the executable is generated. Dynamic bindings make use of dynamic loading to load shared libraries at run time and, therefore, have no link-time dependencies beyond the binding itself. This is explained below.\n\n\nStatic Bindings\n\n\nThe source code for static bindings in D, like those found in the \nDeimos project\n, tends to look very similar to the C or C++ headers for the C library to which they bind. Functions are declared with no implementation. For example:\n\n\nextern(C) void SomeFunction(int);\n\n\n\n\nGiven a C library, \nMyLib\n, which exposes the function \nSomeFunction\n declared above, the user of the D binding for \nMyLib\n must either statically link with the \nMyLib\n static library (\nMyLib.lib\n on Windows, \nlibMylib.a\n elsewhere) or with the \nMyLib\n shared library (the import library \nMyLib.lib\n on Windows, or \nlibMyLib.so\n elsewhere). Additionally, the user must also link with the \nMyLib\n binding itself, most often as a static library, if it contains anything more than delcarations, e.g. helper functions that have implementations.\n\n\nOn Windows, there can be some effort required to link with the C library. At issue is the object file format used by different linkers. For example, when compiling on 32-bit Windows, DMD uses the OPTLINK linker by default, which only understands the \nOMF object format\n. This is the format that was commonly used on Windows back in the DOS days. Modern Windows compilers and linkers more typically use \nCOFF\n instead. As such, most precompiled static and shared libraries available online are in the COFF format. To be used with the default 32-bit DMD toolchain, they must either be converted to OMF using a conversion tool, or the source for the library must be compiled with a compiler that generates OMF files, such as the \nDigital Mars C & C++ Compiler (DMC)\n. However, when compiling with DMD in 64-bit mode, DMD makes use of the Visual C++ toolchain. In this case, the VS linker understands the COFF format, so the conversion step is not necessary. Detailing the object file formats used by every D compiler is beyond the scope of this documentation. It's up to the user to know the output of the tools being used.\n\n\nDifferent people may see different benefits and drawbacks to using static bindings. One of the biggest benefits, perhaps, is that a static binding offers a choice between statically linking with and dynamically linking with a C library. However, no matter which type of linking is chosen, there is no way to escape the link-time dependency imposed by a static binding.\n\n\nDynamic Bindings\n\n\nNot only are dynamic bindings used differently than static bindings, they are implemented differently. Normal function prototypes do not work with dynamic bindings because of the fact that such bindings make use of dynamic loading. All of the functions in the bound library must be declared in the binding as function pointers. The \nMyLib\n example above converted to a dynamic binding format in D might look something like this:\n\n\nextern(C) alias p_SomeFunction = void function(int);\np_SomeFunction SomeFunction;\n\n\n\n\nWhen an application using the \nMyLib\n dynamic binding is compiled, there is no link-time dependency beyond the binding itself. At run time, the dynamic binding will make a call into the OS API to load the \nMyLib\n shared library into the application's memory space. After that, it will again call into the OS API to fetch the address of the \nSomeFunction\n implementation and assign it to the \nSomeFunction\n variable declared above. If successful, then \nSomeFunction\n is ready to use from that point on.\n\n\nAside from eliminating the link-time dependency on the bound library, dynamic bindings give the user control over the case when the shared library fails to load, an event which typically occurs when the library is missing from the user's system, it's missing some symbols the program expects to find, or is otherwise corrupt. When using a static binding with dynamic linking, the OS itself reports an error in these cases, which may not always be desirable. Because a dynamic binding uses dynamic loading, it is possible for the application to detect such errors and react in a manner appropriate for the application, such as displaying a message box with a link to a tech support page.\n\n\nConclusion\n\n\nThe information above is intended to shed light on the difference between static and dynamic bindings. Generally, neither type of binding is \"better\" than the other. For most applications, it probably doesn't matter which type is used as long as the application programmer is comfortable with the concepts of compiling, linking, and loading. The pros and cons of each approach can take on different weights in different contexts, but debating or explaining such is beyond the scope of this documentation.",
            "title": "About Bindings"
        },
        {
            "location": "/bindings/#terminology",
            "text": "Before getting to the differences between the two types of bindings, it would help to understand some relevant terminology as used throughout this documentation. This is especially important since the words  static  and  dynamic  are commonly used in multiple contexts. Understanding the terminology will help to avoid confusion in online discussions or when asking for help.   binding  -- a direct interface to a library in one language that enables the library to be used in another language. Typically, the binding provides a one-to-one mapping to the original interface. For example, the names of all type and function declarations in the Derelict packages correspond exactly to those declared in the original C libraries, except in cases where the original API uses a variable or type name that is a keyword in D. Bindings are sometimes mistakenly referred to as  wrappers .  wrapper  -- a higher-level interface to a library. Wrappers are typically written in the same language as the underlying API, either that of the original library or a binding to that library. For example, a wrapper for OpenGL written in D would be written on top of an OpenGL binding that is also written in D. Wrappers typically provide functionality that makes using the library more convenient. For example, an OpenGL wrapper for D might use classes to represent OpenGL objects such as textures and shaders, encapsulating commonly grouped function calls into single class methods. None of the packages in Derelict are wrappers. They are all bindings. However, D wrappers can be made that use Derelict packages to interface with the C libraries. For example, an OpenGL wrapper can be written on top of  DerelictGL3 .  static linking  -- occurs right after the compile step when building an exectuable with a statically compiled language such as C, C++ or D. All of the object files generated by the compiler are fed to a  linker , which  links  them together, along with any  static libraries  that the application may need, in order to generate the final executable. A static library is an archive containing precompiled object files that are all combined into the final executable. Static libraries on Windows tend to have the  .lib  file extension; static libraries on Posix systems tend to have  .a  extensions. Since the objects in a static library become a part of the executable, they add to its file size. When new versions of a static library are released with bug fixes and improvements, all applications that use it must be recompiled in order to benefit from them.  dynamic linking  -- as with static linking, this happens just after the compile step when building an executable with a statically compiled language such as C, C++ or D. However, instead of linking with a  static library , the linker links with a  shared library  directly or, on Windows systems, with an  import library  (which, confusingly, have the same  .lib  file extension as static libraries). Shared libraries are referred to as  dynamic link libraries  on Windows (usually with the  .dll  extension) and as  shared objects  on most Posix systems (with the  .so  extension). Along with shared object files, one can also find  dynamic libraries  with the  .dylib  extension on Mac OS X. Though the names and file formats may be different, all shared libraries are fundamentally the same. Like static libraries, shared libraries are archive files containing precompiled objects. The difference is that they  are not  combined into the final executable at link time. Instead, information for the system loader is inserted into the executable by the linker. The OS can use this information at run time to load the shared library into memory when the application starts. This allows a single library to be shared by multiple applications, which makes executables smaller and allows all applications using the same library to benefit when the library is updated with bug fixes or improvements, without the need to recompile any of them. It also means that the shared library must be available on the end-user's system in a location that resides on the system library search path.  dynamic loading  -- this is a means of using shared libraries without a link step after compilation. Instead, the shared libraries are loaded manually by the executable at run time. To be clear, dynamic linking has a link-time dependency when the final executable is generated and the OS will automatically load the relevant shared libraries at run time;  dynamic loading  has no link-time dependency and the executable can be generated by the linker without the shared libraries being present on the system. In order for dynamic loading to work, the program must make use of OS-specific APIs (or third-party wrappers) to load the shared libraries into the process memory space. Since the linker is not used to generate locations in memory for the shared library's symbols, the program must declare pointers to the symbols in the shared library that it wants to use and manually match them with the symbols in the shared library after loading it into memory. In other words, the shared library is loaded manually rather than automatically. The shared library must also be available on the end-user's system in a location that is on the system library search path, otherwise the system APIs will not be able to find it. Aside from eliminating link-time dependencies, this approach allows different implementations of a shared library's interface to be easily swapped at run time.",
            "title": "Terminology"
        },
        {
            "location": "/bindings/#dynamic-vs-static-bindings",
            "text": "The primary difference between a dynamic and a static binding is that the former has no link-time dependency on the library to which it binds. Both types require that the bindings themselves be either linked with the executable or compiled along with the application. However, static bindings have the additional requirement that the bound library must be either statically linked (with a static library) or dynamically linked (with a shared library) when the executable is generated. Dynamic bindings make use of dynamic loading to load shared libraries at run time and, therefore, have no link-time dependencies beyond the binding itself. This is explained below.",
            "title": "Dynamic vs. Static Bindings"
        },
        {
            "location": "/bindings/#static-bindings",
            "text": "The source code for static bindings in D, like those found in the  Deimos project , tends to look very similar to the C or C++ headers for the C library to which they bind. Functions are declared with no implementation. For example:  extern(C) void SomeFunction(int);  Given a C library,  MyLib , which exposes the function  SomeFunction  declared above, the user of the D binding for  MyLib  must either statically link with the  MyLib  static library ( MyLib.lib  on Windows,  libMylib.a  elsewhere) or with the  MyLib  shared library (the import library  MyLib.lib  on Windows, or  libMyLib.so  elsewhere). Additionally, the user must also link with the  MyLib  binding itself, most often as a static library, if it contains anything more than delcarations, e.g. helper functions that have implementations.  On Windows, there can be some effort required to link with the C library. At issue is the object file format used by different linkers. For example, when compiling on 32-bit Windows, DMD uses the OPTLINK linker by default, which only understands the  OMF object format . This is the format that was commonly used on Windows back in the DOS days. Modern Windows compilers and linkers more typically use  COFF  instead. As such, most precompiled static and shared libraries available online are in the COFF format. To be used with the default 32-bit DMD toolchain, they must either be converted to OMF using a conversion tool, or the source for the library must be compiled with a compiler that generates OMF files, such as the  Digital Mars C & C++ Compiler (DMC) . However, when compiling with DMD in 64-bit mode, DMD makes use of the Visual C++ toolchain. In this case, the VS linker understands the COFF format, so the conversion step is not necessary. Detailing the object file formats used by every D compiler is beyond the scope of this documentation. It's up to the user to know the output of the tools being used.  Different people may see different benefits and drawbacks to using static bindings. One of the biggest benefits, perhaps, is that a static binding offers a choice between statically linking with and dynamically linking with a C library. However, no matter which type of linking is chosen, there is no way to escape the link-time dependency imposed by a static binding.",
            "title": "Static Bindings"
        },
        {
            "location": "/bindings/#dynamic-bindings",
            "text": "Not only are dynamic bindings used differently than static bindings, they are implemented differently. Normal function prototypes do not work with dynamic bindings because of the fact that such bindings make use of dynamic loading. All of the functions in the bound library must be declared in the binding as function pointers. The  MyLib  example above converted to a dynamic binding format in D might look something like this:  extern(C) alias p_SomeFunction = void function(int);\np_SomeFunction SomeFunction;  When an application using the  MyLib  dynamic binding is compiled, there is no link-time dependency beyond the binding itself. At run time, the dynamic binding will make a call into the OS API to load the  MyLib  shared library into the application's memory space. After that, it will again call into the OS API to fetch the address of the  SomeFunction  implementation and assign it to the  SomeFunction  variable declared above. If successful, then  SomeFunction  is ready to use from that point on.  Aside from eliminating the link-time dependency on the bound library, dynamic bindings give the user control over the case when the shared library fails to load, an event which typically occurs when the library is missing from the user's system, it's missing some symbols the program expects to find, or is otherwise corrupt. When using a static binding with dynamic linking, the OS itself reports an error in these cases, which may not always be desirable. Because a dynamic binding uses dynamic loading, it is possible for the application to detect such errors and react in a manner appropriate for the application, such as displaying a message box with a link to a tech support page.",
            "title": "Dynamic Bindings"
        },
        {
            "location": "/bindings/#conclusion",
            "text": "The information above is intended to shed light on the difference between static and dynamic bindings. Generally, neither type of binding is \"better\" than the other. For most applications, it probably doesn't matter which type is used as long as the application programmer is comfortable with the concepts of compiling, linking, and loading. The pros and cons of each approach can take on different weights in different contexts, but debating or explaining such is beyond the scope of this documentation.",
            "title": "Conclusion"
        },
        {
            "location": "/building/overview/",
            "text": "All of the Derelict packages are configured for convenient compilation via \nDUB\n, the build and package tool for D. There are two ways to go about using DUB to compile any Derelict package for your projects. The recommended way is to \nuse DUB to manage\n your own project. This is easiest and requires little effort to configure. If you [do not use DUB to manage your project], you will still need it to compile the Derelict libraries you want to use. You can then configure your preferred build system or IDE to find the Derelict source and libraries when compiling and linking your project.",
            "title": "Overview"
        },
        {
            "location": "/building/with-dub/",
            "text": "When using DUB to manage a project, it is not neccesary to clone any of the Derelict packages in git. DUB will take care of pulling down the source of the Derelict dependencies, compiling them, and linking them with the executable. It can also make sure that the very latest release of the are used. A great many DUB-enabled libraries other than Derelict can be found in the \nDUB Package Registry\n, all of which can also be automatically compiled and linked with a project simply by editing a configuration file.\n\n\nWhen creating a project for DUB to manage, a configuration file of the name \ndub.json\n or \ndub.sdl\n must be provided. This documentation is not a tutorial on general DUB use, so to learn more about how to configure compile settings and more, please see the \nDUB package format documentation\n. To find help with using DUB, vist the \nDUB forums\n.\n\n\nTo use any package from the DerelictOrg collection in your project, you'll simply need to add the package to your project configuration as a dependency. When you execute \ndub\n or \ndub build\n in the directory where your project configuration lives, DUB will make sure that the dependencies are installed, compiled and linked. You can upgrade to the latest version of each of your project's dependencies by executing \ndub upgrade\n in the same directory.\n\n\nAll packages from DerelictOrg are registered in the DUB registry under names that are formatted in a specific way, derived from the package name. For example, the package DerelictSDL2 is registered as \n\"derelict-sdl2\"\n and the package DerelictGL3 as \n\"derelict-gl3\"\n. Every official Derelict package follows that pattern.\n\n\nSome people maintain Derelict-style packages, using DerelictUtil as a foundation, outside of the DerelictOrg group. These projects often use a similar format for registered names, with the addition of the word \n\"extras\"\n. For example, a third-party package called DerelictFoo might be registered as \n\"derelict-extras-foo\"\n. While this approach is encouraged, not all third-party packages use this format. Some use the same \n\"derelict-foo\"\n format as the \"official\" packages, others might use something else entirely. Please be aware that the DerelictOrg maintainers are not responsible for such packages and any support requests should be directed to the person or persons who are.\n\n\nTo enable any package from the DUB registry, including the Derelict packages, in a DUB-managed project, simply add the registered package name, coupled with a version string, as a dependency in the project configuration. For example, a project using both DerelictSDL2 and DerelictGL3 would have something like the following in its \ndub.json\n:\n\n\n\"dependencies\": {\n    \"derelict-sdl2\": \"~>2.0.0\",\n    \"derelict-gl3\": \"~>1.0.18\"\n}\n\n\n\n\nOr, when using \ndub.sdl\n instead:\n\n\ndependency \"derelict-sdl2\" version=\"~>2.0.0\"\ndependency \"derelict-gl3\" version=\"~>1.0.18\"\n\n\n\n\nThis specifies a version of DerelictSDL2 \ngreater than or equal to\n \n2.0.0\n and \nless than\n \n2.1.0\n, and similarly for DerelictGL3 \n1.0.18\n - \n1.1.0\n. When compiling a project for the first time, DUB will check the local system for any version matching the constraints and, if none is found, will fetch the latest from git that does match. Later, when running \ndub upgrade\n, DUB will look to see if a newer version which matches the constraints is available. For more information on DUB dependencies, see the \nDUB package format documentation\n and the \nDUB Wiki page\n on version management.",
            "title": "When Managing Projects with DUB"
        },
        {
            "location": "/building/without-dub/",
            "text": "When using a build system besides DUB, or an IDE, to manage a Derelict project, the first thing to do is to determine which Derelict packages are required. In the example to follow, a project using DerelictGLFW3 and DerelictGL3 is assumed. Both, like all Derelict packages, have a dependency on DerelictUtil. All three of these packages will need to be obtained manually. One way is to clone them from their git repositories, but then the correct branches must be selected for the specific versions of each package required by the project. It's much simpler to perform a manual fetch with DUB and let it grab the correct branches instead.\n\n\nIt's probably best to use the latest version of DerelictGLFW3 and DerelictGL3. The latest version can be determined by visiting \ncode.dlang.org\n and searching for \nderelict-glfw3\n and \nderelict-gl3\n on that page. Currently, that is \n3.1.0\n for the former and \n1.0.19\n for the latter. It's also necessary to determine which version of DerelictUtil to build against. It should be a version compatible with all of the Derelict packages that will be used with the project. For this example, \n2.0.4\n is used.\n\n\nThe following commands will manually fetch each package.\n\n\nmkdir derelict\ncd derelict\ndub fetch --cache=local derelict-glfw3 --version=3.1.0\ndub fetch --cache=local derelict-gl3 --version=1.0.19\ndub fetch --cache=local derelict-util --version=2.0.4\n\n\n\n\nThis will install each package in subdirectories named using the \npackage-name-x.x.x\n format, e.g. \nderelict-glfw3-3.1.0\n. Both DerelictGLFW3 and DerelictGL3 will need to know where to find the source for DerelictUtil. When manually fetching packages like this, they are not automatically added to the search path, so DUB must be told with the following command.\n\n\ndub add-local derelict-util-2.0.4\n\n\n\n\nWith that, all three packages are ready to build.\n\n\ncd derelict-glfw3-3.1.0\ndub build -brelease\ncd ../derelict-gl3-1.0.19\ndub build -brelease\ncd ../derelict-util-2.0.4\ndub build -brelease\n\n\n\n\nThis will build optimized versions of each library. To build debug versions, omit the \n-brelease\n flag. To explicitly build 64-bit binaries, add \n-ax86_64\n to each command line.\n\n\nFrom here on out, assume \n$DERELICT\n is the path to the derelict directory, whether that is \nC:\\derelict\n or \nC:\\dev\\derelict\n or whatever on Windows, or \n~/dev/derelict\n or whatever on other platforms. Most IDEs and build tools on Windows can work with forward slashes, but change them to backslashes in the following paths if needed.\n\n\nAt this point, a platform-specific library should exist in the \nlib\n sudirectory of each package. In order to compile a project using these libraries, the compiler will first need to be able to find the Derelict source modules so that it can parse the import statements it encounters. The following paths are the ones which must be configure in whatever build system is being used.\n\n\n$DERELICT/derelict-glfw3-2.0.0/source\n$DERELICT/derelict-gl3-1.0.18/source\n$DERELICT/derelict-util-2.0.4/source\n\n\n\n\nIn order to link an executable, the linker will need to know which libraries to link with and where to find them. The libraries needed in this example are shown below, along with their full paths. These will need to be configured appropriately in the build system.\n\n\nOn Windows the libraries are in the \nDerelictFoo.lib\n format.\n\n\n$DERELICT\\derelict-glfw3-2.0.0\\lib\\DerelictGLFW3.lib\n$DERELICT\\derelict-gl3-1.0.18\\lib\\DerelictGL3.lib\n$DERELICT\\derelict-util-2.0.4\\lib\\DerelictUtil.lib\n\n\n\n\nOn POSIX systems the libraries are in the \nlibDerelictFoo.a\n format.\n\n\n$DERELICT/DerelictSDL2/lib/libDerelictSDL2.a\n$DERELICT/DerelictGL3/lib/libDerelictGL3.a\n$DERELICT/DerelictUtil/lib/libDerelictUtil.a\n\n\n\n\nIt may prove convenient to create a common \n$DERELICT/lib\n directory, copy all of the libraries there, and then configure the build system to search for all libraries in that path. Then the path need not be included when specifying each library in the build system's configuration.\n\n\nNote For Non-Windows Systems:\n When building on Mac, Linux, or one of the BSDs), it may also be necessary to link with \nlibdl\n. This is used by DerelictUtil to load shared libraries dynamically at runtime.\n\n\nFailure to properly configure the build system will result in compilation or linker errors. It is beyond the scope of this documentation to describe how to configure the various IDEs and build tools people may use with D. Learning to do so is entirely up to the user.",
            "title": "When Managing Projects without DUB"
        },
        {
            "location": "/loading/loader/",
            "text": "All Derelict packages have one thing in common. Because each package is a dynamic binding, it must be loaded at runtime. The interface for this is the same across all packages.\n\n\nThe \nDerelictUtil\n package contains all of the functionality needed to load a dynamic library at runtime. Each binding contains a loader class that extends from \nSharedLibLoader\n, a class found in \nderelict.util.loader\n. This class exposes two methods for dynamically loading shared libraries.\n\n\nA Normal Load\n\n\nThe method that most developers will use is called \nload\n and takes no arguments. The specific loader on which this method is called will attempt to find and load a shared library, using a predefined set of library names, on the default system shared library path. Loader instances are created automatically in module constructors and, by convention and with few exceptions, are named according to the Derelict package to which they belong. The following example shows how to load the \nSDL2 library\n via \nDerelictSDL2\n.\n\n\nimport derelict.sdl2.sdl;\n\nvoid main()\n{\n    DerelictSDL2.load();\n}\n\n\n\n\nCustom Library Path\n\n\nIt is important to understand the system library path for each system an application is intended to support. For example, on Windows the system loader will search for the SDL DLL first in the application directory, then in the current working directory, then in a couple of predefined system directories before falling back on those specified in the \nPATH\n environment variable (see \nMSDN\n for more details). On other platforms, the application directory and current working directory typically are not searched at all (see \nthis page\n for Linux and \nthis one\n for Mac OS X).\n\n\nThe default library names are selected for each Derelict package based on common formats for each operating system. Sometimes, it is necessary to bypass the default names. For example, a developer may decide to ship special copies of a shared library using a non-standard name, or storing them in a subdirectory under the application directory. In such a case, an overload of the \nload\n method should be used. One form accepts an array of strings, each a library name. Another overload takes single string containing a comma-separated list of library names. Each name can include a path. If no path is specified, the default search path will be used.\n\n\nimport derelict.sdl2.sdl;\n\nversion Windows libName = \"dlls\\\\MySDL2.dll\";\nelse libName = \"MySDL2.so\";\n\nvoid main()\n{\n    DerelictSDL2.load(libName);\n}\n\n\n\n\nSharedLibVersion\n\n\nSome Derelict loaders, but not all, support version-specific loading. In other words, it's possible to tell the loader to attempt to load a lower version of a shared library than the highest version it supports. An example is \nDerelictFI\n.\n\n\nDerelictFI\n is a binding to the \nFreeImage library\n. \nFreeImage\n is supported on every major platform. Most Linux distributions make it available through the system package manager, but the version available is always behind the highest version supported by \nDerelictFI\n. A program that simply calls \nDerelictFI.load()\n on these systems will fail to load the library.\n\n\nTo work around this, a user can choose the minimum required version of \nFreeImage\n. The lowest supported by \nDerelictFI\n is \n3.15.0\n. If none of the functions added in later versions of FreeImage are needed, then the call to \nDerelictFI.load\n can be made like so:\n\n\nDerelictFI.load(SharedLibVersion(3, 15, 0));\n\n\n\n\nCheck the documentation for any Derelict package you use to determine if it supports loading with \nSharedLibVersion\n and, if so, which versions are available as arguments. To future-proof your program, it's a good idea to always use \nSharedLibVersion\n where supported. Simply calling \nload()\n will always attempt to load the highest version supported. If a Derelict package is updated and you release a new version of your app, the app can fail if your users haven't yet updated the library on their system. By always specifying the version of the library that you need, your app will always load newer releases of a library (though you shouldn't expect a \n3.x\n loader to load a \n4.x\n library).",
            "title": "The Derelict Loader"
        },
        {
            "location": "/loading/loader/#a-normal-load",
            "text": "The method that most developers will use is called  load  and takes no arguments. The specific loader on which this method is called will attempt to find and load a shared library, using a predefined set of library names, on the default system shared library path. Loader instances are created automatically in module constructors and, by convention and with few exceptions, are named according to the Derelict package to which they belong. The following example shows how to load the  SDL2 library  via  DerelictSDL2 .  import derelict.sdl2.sdl;\n\nvoid main()\n{\n    DerelictSDL2.load();\n}",
            "title": "A Normal Load"
        },
        {
            "location": "/loading/loader/#custom-library-path",
            "text": "It is important to understand the system library path for each system an application is intended to support. For example, on Windows the system loader will search for the SDL DLL first in the application directory, then in the current working directory, then in a couple of predefined system directories before falling back on those specified in the  PATH  environment variable (see  MSDN  for more details). On other platforms, the application directory and current working directory typically are not searched at all (see  this page  for Linux and  this one  for Mac OS X).  The default library names are selected for each Derelict package based on common formats for each operating system. Sometimes, it is necessary to bypass the default names. For example, a developer may decide to ship special copies of a shared library using a non-standard name, or storing them in a subdirectory under the application directory. In such a case, an overload of the  load  method should be used. One form accepts an array of strings, each a library name. Another overload takes single string containing a comma-separated list of library names. Each name can include a path. If no path is specified, the default search path will be used.  import derelict.sdl2.sdl;\n\nversion Windows libName = \"dlls\\\\MySDL2.dll\";\nelse libName = \"MySDL2.so\";\n\nvoid main()\n{\n    DerelictSDL2.load(libName);\n}",
            "title": "Custom Library Path"
        },
        {
            "location": "/loading/loader/#sharedlibversion",
            "text": "Some Derelict loaders, but not all, support version-specific loading. In other words, it's possible to tell the loader to attempt to load a lower version of a shared library than the highest version it supports. An example is  DerelictFI .  DerelictFI  is a binding to the  FreeImage library .  FreeImage  is supported on every major platform. Most Linux distributions make it available through the system package manager, but the version available is always behind the highest version supported by  DerelictFI . A program that simply calls  DerelictFI.load()  on these systems will fail to load the library.  To work around this, a user can choose the minimum required version of  FreeImage . The lowest supported by  DerelictFI  is  3.15.0 . If none of the functions added in later versions of FreeImage are needed, then the call to  DerelictFI.load  can be made like so:  DerelictFI.load(SharedLibVersion(3, 15, 0));  Check the documentation for any Derelict package you use to determine if it supports loading with  SharedLibVersion  and, if so, which versions are available as arguments. To future-proof your program, it's a good idea to always use  SharedLibVersion  where supported. Simply calling  load()  will always attempt to load the highest version supported. If a Derelict package is updated and you release a new version of your app, the app can fail if your users haven't yet updated the library on their system. By always specifying the version of the library that you need, your app will always load newer releases of a library (though you shouldn't expect a  3.x  loader to load a  4.x  library).",
            "title": "SharedLibVersion"
        },
        {
            "location": "/loading/failure/",
            "text": "Loader Exceptions\n\n\nWhen a shared library cannot be loaded, the loader will throw a sublcass of \nDerelictException\n, which in turn is a subclass of D's \nException\n. More specifically, a \nSharedLibLoadException\n is thrown when a shared library is not present on the system path, or fails to load into memory for some other reason. A \nSymbolLoadException\n is thrown when a function is not found in the shared library. In each case, the exception contains a system-specific error message provided by the operating system API.\n\n\nWhen given an array of library names, the loader will attempt to load each of them in turn. It will only throw a \nSharedLibLoadException\n when the last library name fails to load. When any given symbol fails to load, loading will be aborted and a \nSymbolLoadException\n thrown immediately. To catch and manipulate any of these excptions, import \nderelict.util.exception\n.\n\n\nIn some cases, it may be desirable that the loader continue and no exception be thrown when a symbol is missing. For example, when a Derelict package has been updated to support the latest version of a C library, but the user wants to continue supporting the older version of the C library. One option is to use \nSharedLibVersion\n with any Derelict loader that supports it. See \nLoading a Shared Library\n for more information. Where \nSharedLibVersion\n is not supported, there are two possibilites. The recommended approach is to continue using the version of the Derelict package that supports the minimally required version of the C library. The other option is to use a library a feature called \nselective symbol loading\n.\n\n\nSelective Symbol Loading\n\n\nSelective symbol loading is a means of telling a Derelict loader that it is okay to continue loading a library when a specific symbol is missing. Each loader has a \nmissingSymbolCallback\n property which can be set to either a D delegate or function pointer. The signature in both cases is the same. An example usage follows.\n\n\n// This is needed for the return type enum.\nimport derelict.util.exception : ShouldThrow;\n\nimport derelict.sdl2.sdl;\n\nShouldThrow myMissingSymCB( string symbolName )\n{\n    if( symbolName == \"SDL2_SomeFuncIDon'tNeed\" )\n    {\n        return ShouldThrow.No;\n    }\n    else\n    {\n        return ShouldThrow.Yes;\n    }\n}\n\nvoid main()\n{\n    // Set the callback *before* calling load\n    DerelictSDL2.missingSymbolCallback = &myMissingSymCB;\n    DerelictSDL2.load();\n}\n\n\n\n\nThe use of the \nShouldThrow\n enum makes it easier to remember which value to return when implementing the callback. A simple \ntrue\n or \nfalse\n can sometimes be confusing: does \ntrue\n mean throw or don't throw? Because of the enum, \nderelict.util.exception\n must be imported, but there is no confusion.\n\n\nThe important point here is that the callback must be set \nbefore\n calling the \nload\n method. Otherwise, the loader will have no callback to call. Also note that this is a basic example. There is usually more than one function that must be ignored. When using a \nMissingSymbolCallback\n, it is imperative to check the change log for each new version of the bound C library to understand what has changed between versions so that a complete set of symbol names can be covered. The \nSharedLibVersion\n feature, where supported, uses selective symbol loading internally.",
            "title": "Load Failures"
        },
        {
            "location": "/loading/failure/#loader-exceptions",
            "text": "When a shared library cannot be loaded, the loader will throw a sublcass of  DerelictException , which in turn is a subclass of D's  Exception . More specifically, a  SharedLibLoadException  is thrown when a shared library is not present on the system path, or fails to load into memory for some other reason. A  SymbolLoadException  is thrown when a function is not found in the shared library. In each case, the exception contains a system-specific error message provided by the operating system API.  When given an array of library names, the loader will attempt to load each of them in turn. It will only throw a  SharedLibLoadException  when the last library name fails to load. When any given symbol fails to load, loading will be aborted and a  SymbolLoadException  thrown immediately. To catch and manipulate any of these excptions, import  derelict.util.exception .  In some cases, it may be desirable that the loader continue and no exception be thrown when a symbol is missing. For example, when a Derelict package has been updated to support the latest version of a C library, but the user wants to continue supporting the older version of the C library. One option is to use  SharedLibVersion  with any Derelict loader that supports it. See  Loading a Shared Library  for more information. Where  SharedLibVersion  is not supported, there are two possibilites. The recommended approach is to continue using the version of the Derelict package that supports the minimally required version of the C library. The other option is to use a library a feature called  selective symbol loading .",
            "title": "Loader Exceptions"
        },
        {
            "location": "/loading/failure/#selective-symbol-loading",
            "text": "Selective symbol loading is a means of telling a Derelict loader that it is okay to continue loading a library when a specific symbol is missing. Each loader has a  missingSymbolCallback  property which can be set to either a D delegate or function pointer. The signature in both cases is the same. An example usage follows.  // This is needed for the return type enum.\nimport derelict.util.exception : ShouldThrow;\n\nimport derelict.sdl2.sdl;\n\nShouldThrow myMissingSymCB( string symbolName )\n{\n    if( symbolName == \"SDL2_SomeFuncIDon'tNeed\" )\n    {\n        return ShouldThrow.No;\n    }\n    else\n    {\n        return ShouldThrow.Yes;\n    }\n}\n\nvoid main()\n{\n    // Set the callback *before* calling load\n    DerelictSDL2.missingSymbolCallback = &myMissingSymCB;\n    DerelictSDL2.load();\n}  The use of the  ShouldThrow  enum makes it easier to remember which value to return when implementing the callback. A simple  true  or  false  can sometimes be confusing: does  true  mean throw or don't throw? Because of the enum,  derelict.util.exception  must be imported, but there is no confusion.  The important point here is that the callback must be set  before  calling the  load  method. Otherwise, the loader will have no callback to call. Also note that this is a basic example. There is usually more than one function that must be ignored. When using a  MissingSymbolCallback , it is imperative to check the change log for each new version of the bound C library to understand what has changed between versions so that a complete set of symbol names can be covered. The  SharedLibVersion  feature, where supported, uses selective symbol loading internally.",
            "title": "Selective Symbol Loading"
        }
    ]
}