{
    "docs": [
        {
            "location": "/",
            "text": "Derelict is a collection of dynamic bindings to C and C++ libraries for the D programming language. It enables users to access popular libraries such as OpenGL, SDL, Lua and more, easily and with little effort across several platforms. This set of documentation provides users with the necessary knowledge to get started with Derelict, including general information applicable to all packages in the collection and package-specific information for each package. It is recommended that new Derelict users read the general documentation first, followed by the specific documentation for packages they intend to use.\n\n\nAll Derelict packages make use of the same build and package management system, \nDUB\n, and a common foundation in the form of DerelictUtil. The sections of this documentation that are not package-specific outline the common steps required to configure a project to build and link with Derelict packages, as well as the common interface used to use the Derelict packages in code.\n\n\nWhile the steps to use most Derelict packages are identical, there are sometimes exceptions to the rule. Furthermore, each package has its own versioning scheme independent of the C or C++ library to which it binds. Because of this, before implementing Derelict in a project, it is advised to take the time to read the specific documentation for any packages the project makes use of. This will ensure the project is based on the version of the package appropriate to its requirements and any special steps the package requires can be understood.",
            "title": "Introduction"
        },
        {
            "location": "/support/",
            "text": "A forum used to be maintained specifically for Derelict discussion and support, but it was taken down as the result of a server move and never reopened. There are plans to open a new forum at some point in the future, but for now the best methods to find help with Derelict are, in no particular order:\n\n\n\n\nVist the IRC channel #D on freenode.net. A number of Derelict users are active there.\n\n\nEmail Mike Parker via \naldacron@gmail.com\n.\n\n\nUsers new to both D and Derelict might visit the \nD Newsgroups\n, specifically \ndigitalmars.D.learn\n, which can be accessed via Vladimir Panteleev's \nweb interface\n and a \nmailing list interface\n in addition to standard newsreaders. However, please be aware that this is a generic D newsgroup and not specifically a Derelict support forum. Mike usually checks the newgroups at least once a day, and other regular participants are familiar with Derelict, but there are no guarantees a question about Derelict will be answered promptly.",
            "title": "Support"
        },
        {
            "location": "/overview/",
            "text": "All of the packages in Derelict are \ndynamic bindings\n. Dynamic bindings may not be suitable for every application. Sometimes, \nstatic bindings\n may be more desirable. Before learning how to compile, link and run programs using Derelict, it is useful to understand the difference between the two types of bindings. The page \nAbout Bindings\n explains this along with other terminology used in this documentation that will be helpful when discussing Derelict with others.\n\n\nOnce the decision to use Derelict has been made, the next step is to decide how to manage the project. Derelict is designed to work out of the box with DUB, the build tool and package manager for D. When using Derelict, it is most convenient to use DUB to build and manage the entire application, but it is not required. As long as DUB is available to build the Derelict libraries, they can be used with any build tool or IDE. The page on \nCompiling and Linking\n explains the steps required for both cases. \n\n\nThe last part of this section deals with how to use Derelict at runtime. All Derelict packages have a basic common interface that allow the shared libraries to which they bind to be easily loaded. This is covered in pages on \nLoading Shared Libraries\n and \nLoad Failures\n. Some packages may provide additional features, such as the option to link with a startic C library (in which case no loading is needed), or may require additional steps after the library is loaded. For details, see the package-specific documentation.",
            "title": "Overview"
        },
        {
            "location": "/bindings/",
            "text": "The bindings in Derelict are primarily \ndynamic bindings\n, as opposed to those in the \nDeimos project\n which are all \nstatic bindings\n. This page aims to clarify the difference between the two types of bindings. It is important when starting a new project to understand the implications of each and to select the appropriate type in order to avoid unnecessary frustration.\n\n\nTerminology\n\u00b6\n\n\nBefore getting to the differences between the two types of bindings, it would help to understand some relevant terminology as used throughout this documentation. This is especially important since the words \nstatic\n and \ndynamic\n are commonly used in multiple contexts. Understanding the terminology will help to avoid confusion in online discussions or when asking for help.\n\n\n\n\nbinding\n -- a direct interface to a library in one language that enables the library to be used in another language. Typically, the binding provides a one-to-one mapping to the original interface. For example, the names of all type and function declarations in the Derelict packages correspond exactly to those declared in the original C libraries, except in cases where the original API uses a variable or type name that is a keyword in D. Bindings are sometimes mistakenly referred to as \nwrappers\n.\n\n\nwrapper\n -- a higher-level interface to a library. Wrappers are typically written in the same language as the underlying API, either that of the original library or a binding to that library. For example, a wrapper for OpenGL written in D would be written on top of an OpenGL binding that is also written in D. Wrappers typically provide functionality that makes using the library more convenient. For example, an OpenGL wrapper for D might use classes to represent OpenGL objects such as textures and shaders, encapsulating commonly grouped function calls into single class methods. None of the packages in Derelict are wrappers. They are all bindings. However, D wrappers can be made that use Derelict packages to interface with the C libraries. For example, an OpenGL wrapper can be written on top of \nDerelictGL3\n.\n\n\nstatic linking\n -- occurs right after the compile step when building an exectuable with a statically compiled language such as C, C++ or D. All of the object files generated by the compiler are fed to a \nlinker\n, which \nlinks\n them together, along with any \nstatic libraries\n that the application may need, in order to generate the final executable. A static library is an archive containing precompiled object files that are all combined into the final executable. Static libraries on Windows tend to have the \n.lib\n file extension; static libraries on Posix systems tend to have \n.a\n extensions. Since the objects in a static library become a part of the executable, they add to its file size. When new versions of a static library are released with bug fixes and improvements, all applications that use it must be recompiled in order to benefit from them.\n\n\ndynamic linking\n -- as with static linking, this happens just after the compile step when building an executable with a statically compiled language such as C, C++ or D. However, instead of linking with a \nstatic library\n, the linker links with a \nshared library\n directly or, on Windows systems, with an \nimport library\n (which, confusingly, have the same \n.lib\n file extension as static libraries). Shared libraries are referred to as \ndynamic link libraries\n on Windows (usually with the \n.dll\n extension) and as \nshared objects\n on most Posix systems (with the \n.so\n extension). Along with shared object files, one can also find \ndynamic libraries\n with the \n.dylib\n extension on Mac OS X. Though the names and file formats may be different, all shared libraries are fundamentally the same. Like static libraries, shared libraries are archive files containing precompiled objects. The difference is that they \nare not\n combined into the final executable at link time. Instead, information for the system loader is inserted into the executable by the linker. The OS can use this information at run time to load the shared library into memory when the application starts. This allows a single library to be shared by multiple applications, which makes executables smaller and allows all applications using the same library to benefit when the library is updated with bug fixes or improvements, without the need to recompile any of them. It also means that the shared library must be available on the end-user's system in a location that resides on the system library search path.\n\n\ndynamic loading\n -- this is a means of using shared libraries without a link step after compilation. Instead, the shared libraries are loaded manually by the executable at run time. To be clear, dynamic linking has a link-time dependency when the final executable is generated and the OS will automatically load the relevant shared libraries at run time; \ndynamic loading\n has no link-time dependency and the executable can be generated by the linker without the shared libraries being present on the system. In order for dynamic loading to work, the program must make use of OS-specific APIs (or third-party wrappers) to load the shared libraries into the process memory space. Since the linker is not used to generate locations in memory for the shared library's symbols, the program must declare pointers to the symbols in the shared library that it wants to use and manually match them with the symbols in the shared library after loading it into memory. In other words, the shared library is loaded manually rather than automatically. The shared library must also be available on the end-user's system in a location that is on the system library search path, otherwise the system APIs will not be able to find it. Aside from eliminating link-time dependencies, this approach allows different implementations of a shared library's interface to be easily swapped at run time.\n\n\n\n\nDynamic vs. Static Bindings\n\u00b6\n\n\nThe primary difference between a dynamic and a static binding is that the former has no link-time dependency on the library to which it binds. Both types require that the bindings themselves be either linked with the executable or compiled along with the application. However, static bindings have the additional requirement that the bound library must be either statically linked (with a static library) or dynamically linked (with a shared library) when the executable is generated. Dynamic bindings make use of dynamic loading to load shared libraries at run time and, therefore, have no link-time dependencies beyond the binding itself. This is explained below.\n\n\nStatic Bindings\n\u00b6\n\n\nThe source code for static bindings in D, like those found in the \nDeimos project\n, tends to look very similar to the C or C++ headers for the C library to which they bind. Functions are declared with no implementation. For example:\n\n\nextern\n(\nC\n)\n \nvoid\n \nSomeFunction\n(\nint\n);\n\n\n\n\n\n\nGiven a C library, \nMyLib\n, which exposes the function \nSomeFunction\n declared above, the user of the D binding for \nMyLib\n must either statically link with the \nMyLib\n static library (\nMyLib.lib\n on Windows, \nlibMylib.a\n elsewhere) or with the \nMyLib\n shared library (the import library \nMyLib.lib\n on Windows, or \nlibMyLib.so\n elsewhere). Additionally, the user must also link with the \nMyLib\n binding itself, most often as a static library, if it contains anything more than delcarations, e.g. helper functions that have implementations.\n\n\nOn Windows, there can be some effort required to link with the C library. At issue is the object file format used by different linkers. For example, when compiling on 32-bit Windows, DMD uses the OPTLINK linker by default, which only understands the \nOMF object format\n. This is the format that was commonly used on Windows back in the DOS days. Modern Windows compilers and linkers more typically use \nCOFF\n instead. As such, most precompiled static and shared libraries available online are in the COFF format. To be used with the default 32-bit DMD toolchain, they must either be converted to OMF using a conversion tool, or the source for the library must be compiled with a compiler that generates OMF files, such as the \nDigital Mars C & C++ Compiler (DMC)\n. However, when compiling with DMD in 64-bit mode, DMD makes use of the Visual C++ toolchain. In this case, the VS linker understands the COFF format, so the conversion step is not necessary. Detailing the object file formats used by every D compiler is beyond the scope of this documentation. It's up to the user to know the output of the tools being used.\n\n\nDifferent people may see different benefits and drawbacks to using static bindings. One of the biggest benefits, perhaps, is that a static binding offers a choice between statically linking with and dynamically linking with a C library. However, no matter which type of linking is chosen, there is no way to escape the link-time dependency imposed by a static binding.\n\n\nDynamic Bindings\n\u00b6\n\n\nNot only are dynamic bindings used differently than static bindings, they are implemented differently. Normal function prototypes do not work with dynamic bindings because of the fact that such bindings make use of dynamic loading. All of the functions in the bound library must be declared in the binding as function pointers. The \nMyLib\n example above converted to a dynamic binding format in D might look something like this:\n\n\nextern\n(\nC\n)\n \nalias\n \np_SomeFunction\n \n=\n \nvoid\n \nfunction\n(\nint\n);\n\n\np_SomeFunction\n \nSomeFunction\n;\n\n\n\n\n\n\nWhen an application using the \nMyLib\n dynamic binding is compiled, there is no link-time dependency beyond the binding itself. At run time, the dynamic binding will make a call into the OS API to load the \nMyLib\n shared library into the application's memory space. After that, it will again call into the OS API to fetch the address of the \nSomeFunction\n implementation and assign it to the \nSomeFunction\n variable declared above. If successful, then \nSomeFunction\n is ready to use from that point on.\n\n\nAside from eliminating the link-time dependency on the bound library, dynamic bindings give the user control over the case when the shared library fails to load, an event which typically occurs when the library is missing from the user's system, it's missing some symbols the program expects to find, or is otherwise corrupt. When using a static binding with dynamic linking, the OS itself reports an error in these cases, which may not always be desirable. Because a dynamic binding uses dynamic loading, it is possible for the application to detect such errors and react in a manner appropriate for the application, such as displaying a message box with a link to a tech support page.\n\n\nConclusion\n\u00b6\n\n\nThe information above is intended to shed light on the difference between static and dynamic bindings. Generally, neither type of binding is \"better\" than the other. For most applications, it probably doesn't matter which type is used as long as the application programmer is comfortable with the concepts of compiling, linking, and loading. The pros and cons of each approach can take on different weights in different contexts, but debating or explaining such is beyond the scope of this documentation.",
            "title": "About Bindings"
        },
        {
            "location": "/bindings/#terminology",
            "text": "Before getting to the differences between the two types of bindings, it would help to understand some relevant terminology as used throughout this documentation. This is especially important since the words  static  and  dynamic  are commonly used in multiple contexts. Understanding the terminology will help to avoid confusion in online discussions or when asking for help.   binding  -- a direct interface to a library in one language that enables the library to be used in another language. Typically, the binding provides a one-to-one mapping to the original interface. For example, the names of all type and function declarations in the Derelict packages correspond exactly to those declared in the original C libraries, except in cases where the original API uses a variable or type name that is a keyword in D. Bindings are sometimes mistakenly referred to as  wrappers .  wrapper  -- a higher-level interface to a library. Wrappers are typically written in the same language as the underlying API, either that of the original library or a binding to that library. For example, a wrapper for OpenGL written in D would be written on top of an OpenGL binding that is also written in D. Wrappers typically provide functionality that makes using the library more convenient. For example, an OpenGL wrapper for D might use classes to represent OpenGL objects such as textures and shaders, encapsulating commonly grouped function calls into single class methods. None of the packages in Derelict are wrappers. They are all bindings. However, D wrappers can be made that use Derelict packages to interface with the C libraries. For example, an OpenGL wrapper can be written on top of  DerelictGL3 .  static linking  -- occurs right after the compile step when building an exectuable with a statically compiled language such as C, C++ or D. All of the object files generated by the compiler are fed to a  linker , which  links  them together, along with any  static libraries  that the application may need, in order to generate the final executable. A static library is an archive containing precompiled object files that are all combined into the final executable. Static libraries on Windows tend to have the  .lib  file extension; static libraries on Posix systems tend to have  .a  extensions. Since the objects in a static library become a part of the executable, they add to its file size. When new versions of a static library are released with bug fixes and improvements, all applications that use it must be recompiled in order to benefit from them.  dynamic linking  -- as with static linking, this happens just after the compile step when building an executable with a statically compiled language such as C, C++ or D. However, instead of linking with a  static library , the linker links with a  shared library  directly or, on Windows systems, with an  import library  (which, confusingly, have the same  .lib  file extension as static libraries). Shared libraries are referred to as  dynamic link libraries  on Windows (usually with the  .dll  extension) and as  shared objects  on most Posix systems (with the  .so  extension). Along with shared object files, one can also find  dynamic libraries  with the  .dylib  extension on Mac OS X. Though the names and file formats may be different, all shared libraries are fundamentally the same. Like static libraries, shared libraries are archive files containing precompiled objects. The difference is that they  are not  combined into the final executable at link time. Instead, information for the system loader is inserted into the executable by the linker. The OS can use this information at run time to load the shared library into memory when the application starts. This allows a single library to be shared by multiple applications, which makes executables smaller and allows all applications using the same library to benefit when the library is updated with bug fixes or improvements, without the need to recompile any of them. It also means that the shared library must be available on the end-user's system in a location that resides on the system library search path.  dynamic loading  -- this is a means of using shared libraries without a link step after compilation. Instead, the shared libraries are loaded manually by the executable at run time. To be clear, dynamic linking has a link-time dependency when the final executable is generated and the OS will automatically load the relevant shared libraries at run time;  dynamic loading  has no link-time dependency and the executable can be generated by the linker without the shared libraries being present on the system. In order for dynamic loading to work, the program must make use of OS-specific APIs (or third-party wrappers) to load the shared libraries into the process memory space. Since the linker is not used to generate locations in memory for the shared library's symbols, the program must declare pointers to the symbols in the shared library that it wants to use and manually match them with the symbols in the shared library after loading it into memory. In other words, the shared library is loaded manually rather than automatically. The shared library must also be available on the end-user's system in a location that is on the system library search path, otherwise the system APIs will not be able to find it. Aside from eliminating link-time dependencies, this approach allows different implementations of a shared library's interface to be easily swapped at run time.",
            "title": "Terminology"
        },
        {
            "location": "/bindings/#dynamic-vs-static-bindings",
            "text": "The primary difference between a dynamic and a static binding is that the former has no link-time dependency on the library to which it binds. Both types require that the bindings themselves be either linked with the executable or compiled along with the application. However, static bindings have the additional requirement that the bound library must be either statically linked (with a static library) or dynamically linked (with a shared library) when the executable is generated. Dynamic bindings make use of dynamic loading to load shared libraries at run time and, therefore, have no link-time dependencies beyond the binding itself. This is explained below.",
            "title": "Dynamic vs. Static Bindings"
        },
        {
            "location": "/bindings/#static-bindings",
            "text": "The source code for static bindings in D, like those found in the  Deimos project , tends to look very similar to the C or C++ headers for the C library to which they bind. Functions are declared with no implementation. For example:  extern ( C )   void   SomeFunction ( int );   Given a C library,  MyLib , which exposes the function  SomeFunction  declared above, the user of the D binding for  MyLib  must either statically link with the  MyLib  static library ( MyLib.lib  on Windows,  libMylib.a  elsewhere) or with the  MyLib  shared library (the import library  MyLib.lib  on Windows, or  libMyLib.so  elsewhere). Additionally, the user must also link with the  MyLib  binding itself, most often as a static library, if it contains anything more than delcarations, e.g. helper functions that have implementations.  On Windows, there can be some effort required to link with the C library. At issue is the object file format used by different linkers. For example, when compiling on 32-bit Windows, DMD uses the OPTLINK linker by default, which only understands the  OMF object format . This is the format that was commonly used on Windows back in the DOS days. Modern Windows compilers and linkers more typically use  COFF  instead. As such, most precompiled static and shared libraries available online are in the COFF format. To be used with the default 32-bit DMD toolchain, they must either be converted to OMF using a conversion tool, or the source for the library must be compiled with a compiler that generates OMF files, such as the  Digital Mars C & C++ Compiler (DMC) . However, when compiling with DMD in 64-bit mode, DMD makes use of the Visual C++ toolchain. In this case, the VS linker understands the COFF format, so the conversion step is not necessary. Detailing the object file formats used by every D compiler is beyond the scope of this documentation. It's up to the user to know the output of the tools being used.  Different people may see different benefits and drawbacks to using static bindings. One of the biggest benefits, perhaps, is that a static binding offers a choice between statically linking with and dynamically linking with a C library. However, no matter which type of linking is chosen, there is no way to escape the link-time dependency imposed by a static binding.",
            "title": "Static Bindings"
        },
        {
            "location": "/bindings/#dynamic-bindings",
            "text": "Not only are dynamic bindings used differently than static bindings, they are implemented differently. Normal function prototypes do not work with dynamic bindings because of the fact that such bindings make use of dynamic loading. All of the functions in the bound library must be declared in the binding as function pointers. The  MyLib  example above converted to a dynamic binding format in D might look something like this:  extern ( C )   alias   p_SomeFunction   =   void   function ( int );  p_SomeFunction   SomeFunction ;   When an application using the  MyLib  dynamic binding is compiled, there is no link-time dependency beyond the binding itself. At run time, the dynamic binding will make a call into the OS API to load the  MyLib  shared library into the application's memory space. After that, it will again call into the OS API to fetch the address of the  SomeFunction  implementation and assign it to the  SomeFunction  variable declared above. If successful, then  SomeFunction  is ready to use from that point on.  Aside from eliminating the link-time dependency on the bound library, dynamic bindings give the user control over the case when the shared library fails to load, an event which typically occurs when the library is missing from the user's system, it's missing some symbols the program expects to find, or is otherwise corrupt. When using a static binding with dynamic linking, the OS itself reports an error in these cases, which may not always be desirable. Because a dynamic binding uses dynamic loading, it is possible for the application to detect such errors and react in a manner appropriate for the application, such as displaying a message box with a link to a tech support page.",
            "title": "Dynamic Bindings"
        },
        {
            "location": "/bindings/#conclusion",
            "text": "The information above is intended to shed light on the difference between static and dynamic bindings. Generally, neither type of binding is \"better\" than the other. For most applications, it probably doesn't matter which type is used as long as the application programmer is comfortable with the concepts of compiling, linking, and loading. The pros and cons of each approach can take on different weights in different contexts, but debating or explaining such is beyond the scope of this documentation.",
            "title": "Conclusion"
        },
        {
            "location": "/building/overview/",
            "text": "All of the Derelict packages are configured for convenient compilation via \nDUB\n, the build and package tool for D. There are two ways to go about using DUB to compile any Derelict package for your projects. The recommended way is to \nuse DUB to manage\n your own project. This is easiest and requires little effort to configure. If you [do not use DUB to manage your project], you will still need it to compile the Derelict libraries you want to use. You can then configure your preferred build system or IDE to find the Derelict source and libraries when compiling and linking your project.",
            "title": "Overview"
        },
        {
            "location": "/building/with-dub/",
            "text": "When using DUB to manage a project, it is not neccesary to clone any of the Derelict packages with git. DUB will take care of pulling down the source of the Derelict dependencies, compiling them, and linking them with the executable. A number of DUB-enabled libraries other than Derelict can be found in the \nDUB Package Registry\n, all of which can also be automatically compiled and linked with a project simply by editing a configuration file.\n\n\nGeneral configuration\n\u00b6\n\n\n\n\nNote\n\n\nNone of the C libraries to which the Derelict libraries bind are bundled with the packages. The binaries for the C libraries must be obtained separately, either through downloading precompiled binaries from project websites, repositories, or third-party packagers, or by downloading and obtaining the source. Where possible, suggestions on how to obtain binaries and/or source are included in the package-specific documentation.\n\n\n\n\nWhen creating a project for DUB to manage, a configuration file of the name \ndub.json\n or \ndub.sdl\n must be provided. This documentation is not a tutorial on general DUB use, so to learn more about using DUB from the command line and configuring DUB packages, please see the \nDUB documentation\n. For more DUB assitance, visit the \nDUB forums\n.\n\n\nTo use any package from the DerelictOrg collection in your project, you'll simply need to add it to your project configuration as a dependency. When you execute \ndub\n or \ndub build\n in your project configuration's root directory, DUB will make sure that the dependencies are installed, compiled and linked. You can upgrade to the latest version of each of your project's dependencies by executing \ndub upgrade\n in the same directory.\n\n\nAll packages from DerelictOrg are registered in the DUB registry under names that are formatted in a specific format derived from the package name. For example, the package DerelictSDL2 is registered as \nderelict-sdl2\n and the package DerelictGL3 as \nderelict-gl3\n. Every Derelict package under the DerelictOrg umbrella follows that pattern.\n\n\nSome people maintain third-party Derelict-style packages, using DerelictUtil as a foundation, outside of the DerelictOrg group. Some of these packages are registred with names using a format that puts \nderelict-extras\n in front of the package name. For example, a third-party package called DerelictFoo might be registered as \nderelict-extras-foo\n. While this approach is encouraged, many such packages are still registered as \nderelict-foo\n. Still others might use another format entirely. Please be aware that the DerelictOrg maintainers are not responsible for such packages and any support requests should be directed to the person or persons who are via the links to their source repositories from the package pages at the \nDUB Package Registry\n.\n\n\nTo enable any package from the DUB registry, including the Derelict packages, in a DUB-managed project, simply add the registered package name, coupled with a version string, as a dependency in the project configuration. For example, a project using both DerelictSDL2 and DerelictGL3 would have something like the following in its configuration:\n\n\ndub.json\n\n\n\"dependencies\"\n:\n \n{\n\n    \n\"derelict-sdl2\"\n:\n \n\"~>3.0.0\"\n,\n\n    \n\"derelict-gl3\"\n:\n \n\"~>2.0.0\"\n\n\n}\n\n\n\n\n\n\ndub.sdl\n\n\ndependency \n\"derelict-sdl2\"\n \nversion\n=\n\"~>3.0.0\"\n\ndependency \n\"derelict-gl3\"\n \nversion\n=\n\"~>2.0.0\"\n\n\n\n\n\n\nThis specifies a version of DerelictSDL2 \ngreater than or equal to\n \n2.0.0\n and \nless than\n \n2.1.0\n, and similarly for DerelictGL3 \n1.0.18\n - \n1.1.0\n. When compiling a project for the first time, DUB will check the local system for any version matching the constraints and, if none is found, will fetch the latest from git that does match. Later, when running \ndub upgrade\n, DUB will look to see if a newer version which matches the constraints is available. For more information on DUB dependencies, see the \nDUB documentation\n and the \nDUB Wiki page\n on version management. See the page \nLatest Versions\n for a table of all of the latest release version tags for the supported DerelictOrg packages.\n\n\nDynamic bindings\n\u00b6\n\n\nAll Derelict packages are configured as dynamic bindings by default (see \nthis page\n to understand the difference between static and dynamic bindings). This does not mean they require dynamic linking. There is no link-time dependency at all. Instead, the C shared library is loaded manually at runtime with a call to a \nload\n function on a loader instance, e.g. \nDerelictSDL2.load\n.\n\n\nFor this to work, the shared library needs to be on the system path. On Posix systems, that usually means installing from the package manager. It is not necessary to install the development packages for this to work, given the lack of a link-time dependency. For example, Ubuntu users can install SDL via \nsudo apt-get install libsdl2-2.0\n, but need not install \nlibsdl2-dev\n. On Windows, this usually means placing the C DLL in the executable's directory, though \nDerelict loaders\n support loading from custom locations, e.g. \nDerelictSDL2.load(\"dlls/SDL2.dll\")\n.\n\n\nStatic bindings\n\u00b6\n\n\nDerelict packages that support a static binding configuration can be configured using a \nsubConfiguration\n entry in the project config, or a \nversions\n entry. The subconfigurations are in the format of \npackage-name-static\n, e.g. \nderelict-sdl2-static\n. This is the preferred approach, as it completely eliminates the dynamic binding modules from the build.\n\n\ndub.json\n\n\n\"subConfigurations\"\n:\n \n{\n\n    \n\"derelict-sdl2\"\n:\n \n\"derelict-sdl2-static\"\n\n\n}\n\n\n\n\n\n\ndub.sdl\n\n\nsubConfiguration \n\"derelict-sdl2\"\n \n\"derelict-sdl2-static\"\n\n\n\n\n\n\nVersions can be \nDerelict_Static\n, which enables the static binding configuration for all packages in a project that support it, or \nPackageName_Static\n, e.g. \nDerelictSDL2_Static\n which enables it for the specific package.\n\n\ndub.json\n\n\n\"versions\"\n:\n \n[\n\"DerelictSDL2_Static\"\n]\n\n\n\n\n\n\ndub.sdl\n\n\nversions \n\"DerelictSDL2_Static\"\n\n\n\n\n\n\nStatic binding configurations require linking either dynamically or statically with the library at runtime. Generally, on Posix systems this requires installing the development version of the C library through a package manager or compiling from source. The appropriate libraries will be installed on the system path. On Windows, it requires downloading the precompiled development packages or compiling from source, making sure the linker can find the library, and, when linking dynamically, ensuring the DLL is in the compiled executable's directory.\n\n\nThe documentation for each package that supports static binding provides package-specific details.",
            "title": "With DUB Projects"
        },
        {
            "location": "/building/with-dub/#general-configuration",
            "text": "Note  None of the C libraries to which the Derelict libraries bind are bundled with the packages. The binaries for the C libraries must be obtained separately, either through downloading precompiled binaries from project websites, repositories, or third-party packagers, or by downloading and obtaining the source. Where possible, suggestions on how to obtain binaries and/or source are included in the package-specific documentation.   When creating a project for DUB to manage, a configuration file of the name  dub.json  or  dub.sdl  must be provided. This documentation is not a tutorial on general DUB use, so to learn more about using DUB from the command line and configuring DUB packages, please see the  DUB documentation . For more DUB assitance, visit the  DUB forums .  To use any package from the DerelictOrg collection in your project, you'll simply need to add it to your project configuration as a dependency. When you execute  dub  or  dub build  in your project configuration's root directory, DUB will make sure that the dependencies are installed, compiled and linked. You can upgrade to the latest version of each of your project's dependencies by executing  dub upgrade  in the same directory.  All packages from DerelictOrg are registered in the DUB registry under names that are formatted in a specific format derived from the package name. For example, the package DerelictSDL2 is registered as  derelict-sdl2  and the package DerelictGL3 as  derelict-gl3 . Every Derelict package under the DerelictOrg umbrella follows that pattern.  Some people maintain third-party Derelict-style packages, using DerelictUtil as a foundation, outside of the DerelictOrg group. Some of these packages are registred with names using a format that puts  derelict-extras  in front of the package name. For example, a third-party package called DerelictFoo might be registered as  derelict-extras-foo . While this approach is encouraged, many such packages are still registered as  derelict-foo . Still others might use another format entirely. Please be aware that the DerelictOrg maintainers are not responsible for such packages and any support requests should be directed to the person or persons who are via the links to their source repositories from the package pages at the  DUB Package Registry .  To enable any package from the DUB registry, including the Derelict packages, in a DUB-managed project, simply add the registered package name, coupled with a version string, as a dependency in the project configuration. For example, a project using both DerelictSDL2 and DerelictGL3 would have something like the following in its configuration:  dub.json  \"dependencies\" :   { \n     \"derelict-sdl2\" :   \"~>3.0.0\" , \n     \"derelict-gl3\" :   \"~>2.0.0\"  }   dub.sdl  dependency  \"derelict-sdl2\"   version = \"~>3.0.0\" \ndependency  \"derelict-gl3\"   version = \"~>2.0.0\"   This specifies a version of DerelictSDL2  greater than or equal to   2.0.0  and  less than   2.1.0 , and similarly for DerelictGL3  1.0.18  -  1.1.0 . When compiling a project for the first time, DUB will check the local system for any version matching the constraints and, if none is found, will fetch the latest from git that does match. Later, when running  dub upgrade , DUB will look to see if a newer version which matches the constraints is available. For more information on DUB dependencies, see the  DUB documentation  and the  DUB Wiki page  on version management. See the page  Latest Versions  for a table of all of the latest release version tags for the supported DerelictOrg packages.",
            "title": "General configuration"
        },
        {
            "location": "/building/with-dub/#dynamic-bindings",
            "text": "All Derelict packages are configured as dynamic bindings by default (see  this page  to understand the difference between static and dynamic bindings). This does not mean they require dynamic linking. There is no link-time dependency at all. Instead, the C shared library is loaded manually at runtime with a call to a  load  function on a loader instance, e.g.  DerelictSDL2.load .  For this to work, the shared library needs to be on the system path. On Posix systems, that usually means installing from the package manager. It is not necessary to install the development packages for this to work, given the lack of a link-time dependency. For example, Ubuntu users can install SDL via  sudo apt-get install libsdl2-2.0 , but need not install  libsdl2-dev . On Windows, this usually means placing the C DLL in the executable's directory, though  Derelict loaders  support loading from custom locations, e.g.  DerelictSDL2.load(\"dlls/SDL2.dll\") .",
            "title": "Dynamic bindings"
        },
        {
            "location": "/building/with-dub/#static-bindings",
            "text": "Derelict packages that support a static binding configuration can be configured using a  subConfiguration  entry in the project config, or a  versions  entry. The subconfigurations are in the format of  package-name-static , e.g.  derelict-sdl2-static . This is the preferred approach, as it completely eliminates the dynamic binding modules from the build.  dub.json  \"subConfigurations\" :   { \n     \"derelict-sdl2\" :   \"derelict-sdl2-static\"  }   dub.sdl  subConfiguration  \"derelict-sdl2\"   \"derelict-sdl2-static\"   Versions can be  Derelict_Static , which enables the static binding configuration for all packages in a project that support it, or  PackageName_Static , e.g.  DerelictSDL2_Static  which enables it for the specific package.  dub.json  \"versions\" :   [ \"DerelictSDL2_Static\" ]   dub.sdl  versions  \"DerelictSDL2_Static\"   Static binding configurations require linking either dynamically or statically with the library at runtime. Generally, on Posix systems this requires installing the development version of the C library through a package manager or compiling from source. The appropriate libraries will be installed on the system path. On Windows, it requires downloading the precompiled development packages or compiling from source, making sure the linker can find the library, and, when linking dynamically, ensuring the DLL is in the compiled executable's directory.  The documentation for each package that supports static binding provides package-specific details.",
            "title": "Static bindings"
        },
        {
            "location": "/building/without-dub/",
            "text": "When using a build system besides DUB, or an IDE, to manage a Derelict project, the first thing to do is to determine which Derelict packages are required. In the example to follow, a project using DerelictGLFW3 and DerelictGL3 is assumed. Both, like all Derelict packages, have a dependency on DerelictUtil. All three of these packages will need to be obtained manually. One way is to clone them from their git repositories, but then the correct branches must be selected for the specific versions of each package required by the project. It's much simpler to perform a manual fetch with DUB and let it grab the correct branches instead.\n\n\nIt's probably best to use the latest version of DerelictGLFW3 and DerelictGL3. The latest version can be determined by visiting \ncode.dlang.org\n and searching for \nderelict-glfw3\n and \nderelict-gl3\n on that page. Currently, that is \n3.1.0\n for the former and \n1.0.19\n for the latter. It's also necessary to determine which version of DerelictUtil to build against. It should be a version compatible with all of the Derelict packages that will be used with the project. For this example, \n2.0.4\n is used.\n\n\nThe following commands will manually fetch each package.\n\n\nmkdir derelict\ncd derelict\ndub fetch --cache=local derelict-glfw3 --version=3.1.0\ndub fetch --cache=local derelict-gl3 --version=1.0.19\ndub fetch --cache=local derelict-util --version=2.0.4\n\n\n\n\n\nThis will install each package in subdirectories named using the \npackage-name-x.x.x\n format, e.g. \nderelict-glfw3-3.1.0\n. Both DerelictGLFW3 and DerelictGL3 will need to know where to find the source for DerelictUtil. When manually fetching packages like this, they are not automatically added to the search path, so DUB must be told with the following command.\n\n\ndub add-local derelict-util-2.0.4\n\n\n\n\n\nWith that, all three packages are ready to build.\n\n\ncd derelict-glfw3-3.1.0\ndub build -brelease\ncd ../derelict-gl3-1.0.19\ndub build -brelease\ncd ../derelict-util-2.0.4\ndub build -brelease\n\n\n\n\n\nThis will build optimized versions of each library. To build debug versions, omit the \n-brelease\n flag. To explicitly build 64-bit binaries, add \n-ax86_64\n to each command line.\n\n\nFrom here on out, assume \n$DERELICT\n is the path to the derelict directory, whether that is \nC:\\derelict\n or \nC:\\dev\\derelict\n or whatever on Windows, or \n~/dev/derelict\n or whatever on other platforms. Most IDEs and build tools on Windows can work with forward slashes, but change them to backslashes in the following paths if needed.\n\n\nAt this point, a platform-specific library should exist in the \nlib\n sudirectory of each package. In order to compile a project using these libraries, the compiler will first need to be able to find the Derelict source modules so that it can parse the import statements it encounters. The following paths are the ones which must be configure in whatever build system is being used.\n\n\n$DERELICT/derelict-glfw3-2.0.0/source\n$DERELICT/derelict-gl3-1.0.18/source\n$DERELICT/derelict-util-2.0.4/source\n\n\n\n\n\nIn order to link an executable, the linker will need to know which libraries to link with and where to find them. The libraries needed in this example are shown below, along with their full paths. These will need to be configured appropriately in the build system.\n\n\nOn Windows the libraries are in the \nDerelictFoo.lib\n format.\n\n\n$DERELICT\\derelict-glfw3-2.0.0\\lib\\DerelictGLFW3.lib\n$DERELICT\\derelict-gl3-1.0.18\\lib\\DerelictGL3.lib\n$DERELICT\\derelict-util-2.0.4\\lib\\DerelictUtil.lib\n\n\n\n\n\nOn POSIX systems the libraries are in the \nlibDerelictFoo.a\n format.\n\n\n$DERELICT/DerelictSDL2/lib/libDerelictSDL2.a\n$DERELICT/DerelictGL3/lib/libDerelictGL3.a\n$DERELICT/DerelictUtil/lib/libDerelictUtil.a\n\n\n\n\n\nIt may prove convenient to create a common \n$DERELICT/lib\n directory, copy all of the libraries there, and then configure the build system to search for all libraries in that path. Then the path need not be included when specifying each library in the build system's configuration.\n\n\nNote For Non-Windows Systems:\n When building on Mac, Linux, or one of the BSDs), it may also be necessary to link with \nlibdl\n. This is used by DerelictUtil to load shared libraries dynamically at runtime.\n\n\nFailure to properly configure the build system will result in compilation or linker errors. It is beyond the scope of this documentation to describe how to configure the various IDEs and build tools people may use with D. Learning to do so is entirely up to the user.",
            "title": "With Non-DUB Projects"
        },
        {
            "location": "/building/windows/",
            "text": "On all of the systems D supports but one, developers can rely on a standard ecosystem of compiler toolchains, including linkers. The three major D compilers all use the system linker on those systems. The outlier is Windows. \n\n\nWhen using any Derelict package as a dynamic binding, none of the information on this page applies. It only applies when using any static binding, whether it be one of the Derelict packages that supports such a configuration or a non-Derelict library. In other words, when developing D programs that have a link-time dependency with third-party libraries on Windows, a few prerequisites need to be understood.\n\n\nOf the three main compilers, only DMD and LDC actively support Windows. GDC has not had a Windows release for some time (though that will likely change now that the compiler has been accepted into the GCC compiler suite). The following sections look at each compiler in turn.\n\n\nDownload links for all three compilers can be found at the \ndlang.org downloads page\n.\n\n\nDMD\n\u00b6\n\n\nDMD is the reference D compiler, developed primarily by D's creator and \nDigital Mars\n owner, \nWalter Bright\n.\n\n\nDMD is built on top of the same compiler backend as the Digital Mars C/C++ compiler, \nDMC\n. It ships with \nOPTLINK\n, an ancient linker that only knows how to link 32-bit executables composed of object files in the \nOMF\n format. When passing the \n-m32\n command line switch (the default for the 32-bit version of DMD, currently the only version distributed in binary form on Windows), DMD's object output will be in the OMF format and it will use the OPTLINK linker to create executables.\n\n\nThankfully, DMD also supports generating object files in the \nCOFF\n format and linking using the Microsoft linker. This is enabled via the \n-m32mscoff\n command line switch for 32-bit binaries, and \n-m64\n for 64-bit binaries.This requires the installation of either the Microsoft Build Tools and the Windows SDK, or a supported version of Visual Studio. If you do not already have any of these installed, the easiest thing to do is to install the latest Visual Studio \nVisual Studio Community Edition\n.\n\n\n\n\nNote\n\n\nGenerally, you can expect Visual Studio versions 2012 and later to be supported, though sometimes new versions may temporarily break support in some way. For example, due to changes in the path structure in VS 2017, the DMD installer could not automatically identify it for a time, so it could not properly configure DMD. Paths can always be configured manually, but VS 2015 renamed the C runtime library, a breakage that can only be fixed by the DMD developers. Any breakage is generally fixed within a DMD release or two. In the interim, the previous Visual Studio version should continue to work.\n\n\n\n\nTo reiterate, when using the dynamic binding configuration of a Derelict package, the DLL can be in any format and compiled with any Windows compiler. As long as 32-bit executables are loading 32-bit DLLs, and 64-bit executables are loading 64-bit DLLs, the object file format is irrelevant. It only applies when linking in a static binding configuration.\n\n\nCOFF\n\u00b6\n\n\nOnce the Microsoft linker and libraries are installed, DMD needs to be told where to find them. While it's possible to edit the DMD configuration file (\nsc.ini\n in the \ndmd2\\windows\\bin\n directory), it's much easier to let the DMD Windows installer handle it automatically. When everything is configured, any libraries that have a link-time dependency must be in the COFF format.\n\n\nEffectively, this means that when using a Derelict package in a static binding configuration (where supported), you should always either choose binary packages compiled with Visual C++, or use Visual C++ to compile the library yourself. For example, to use the \nDerelictSDL2\n static binding configuration, go to \nlibsdl.org\n and download the appropriate SDL development libraries for Visual C++, e.g. \nSDL-devel-2.0.5-VC.zip\n.\n\n\nOMF\n\u00b6\n\n\nWhy are you even thinking about compiling in OMF format? Just don't! But if you must, don't even bother to look for precompiled OMF binaries for any library to which Derelict binds. They may be out there somewhere, but you're better off either running an object converter or compiling yourself with DMC. The former is the recommended approach, as few libraries have a build system that supports DMC out of the box.\n\n\nThe first thing to do is to head to the Digital Mars site to download the Extended Utility Package (\nEUP\n). This contains two tools that will do the job. When you are linking dynamically with a DLL import library, run the \ncoffimplib\n utility on the COFF DLL (such as the \nSDL2.dll\n obtained in the VC development archive from the SDL downloads page). This will produce an import library in OMF format that will link with the COFF DLL. When linking statically, run \ncoff2omf\n on the COFF static library or any COFF object files you need to link with. This will produce libraries or object files in the OMF format.\n\n\nLDC\n\u00b6\n\n\nOlder LDC releases for Windows were built on top of \nmingw-w64\n, but recent releases require the Microsoft tools and libraries. The same COFF instructions in the DMD section above apply here.\n\n\nGDC\n\u00b6\n\n\nThere has not been a GDC release for Windows in some time. If there eventually is, it will assumedly be built on top of mingw-w64. In that case, only binaries compiled with mingw-w64, either downloaded in precompiled packages or compiled yourself, will be compatible. While the MinGW linker does support COFF, and can sometimes link with binaries compiled with Visual C++, there are often linker errors that need to be worked around. Best not to mix them.",
            "title": "Compiling on Windows"
        },
        {
            "location": "/building/windows/#dmd",
            "text": "DMD is the reference D compiler, developed primarily by D's creator and  Digital Mars  owner,  Walter Bright .  DMD is built on top of the same compiler backend as the Digital Mars C/C++ compiler,  DMC . It ships with  OPTLINK , an ancient linker that only knows how to link 32-bit executables composed of object files in the  OMF  format. When passing the  -m32  command line switch (the default for the 32-bit version of DMD, currently the only version distributed in binary form on Windows), DMD's object output will be in the OMF format and it will use the OPTLINK linker to create executables.  Thankfully, DMD also supports generating object files in the  COFF  format and linking using the Microsoft linker. This is enabled via the  -m32mscoff  command line switch for 32-bit binaries, and  -m64  for 64-bit binaries.This requires the installation of either the Microsoft Build Tools and the Windows SDK, or a supported version of Visual Studio. If you do not already have any of these installed, the easiest thing to do is to install the latest Visual Studio  Visual Studio Community Edition .   Note  Generally, you can expect Visual Studio versions 2012 and later to be supported, though sometimes new versions may temporarily break support in some way. For example, due to changes in the path structure in VS 2017, the DMD installer could not automatically identify it for a time, so it could not properly configure DMD. Paths can always be configured manually, but VS 2015 renamed the C runtime library, a breakage that can only be fixed by the DMD developers. Any breakage is generally fixed within a DMD release or two. In the interim, the previous Visual Studio version should continue to work.   To reiterate, when using the dynamic binding configuration of a Derelict package, the DLL can be in any format and compiled with any Windows compiler. As long as 32-bit executables are loading 32-bit DLLs, and 64-bit executables are loading 64-bit DLLs, the object file format is irrelevant. It only applies when linking in a static binding configuration.",
            "title": "DMD"
        },
        {
            "location": "/building/windows/#coff",
            "text": "Once the Microsoft linker and libraries are installed, DMD needs to be told where to find them. While it's possible to edit the DMD configuration file ( sc.ini  in the  dmd2\\windows\\bin  directory), it's much easier to let the DMD Windows installer handle it automatically. When everything is configured, any libraries that have a link-time dependency must be in the COFF format.  Effectively, this means that when using a Derelict package in a static binding configuration (where supported), you should always either choose binary packages compiled with Visual C++, or use Visual C++ to compile the library yourself. For example, to use the  DerelictSDL2  static binding configuration, go to  libsdl.org  and download the appropriate SDL development libraries for Visual C++, e.g.  SDL-devel-2.0.5-VC.zip .",
            "title": "COFF"
        },
        {
            "location": "/building/windows/#omf",
            "text": "Why are you even thinking about compiling in OMF format? Just don't! But if you must, don't even bother to look for precompiled OMF binaries for any library to which Derelict binds. They may be out there somewhere, but you're better off either running an object converter or compiling yourself with DMC. The former is the recommended approach, as few libraries have a build system that supports DMC out of the box.  The first thing to do is to head to the Digital Mars site to download the Extended Utility Package ( EUP ). This contains two tools that will do the job. When you are linking dynamically with a DLL import library, run the  coffimplib  utility on the COFF DLL (such as the  SDL2.dll  obtained in the VC development archive from the SDL downloads page). This will produce an import library in OMF format that will link with the COFF DLL. When linking statically, run  coff2omf  on the COFF static library or any COFF object files you need to link with. This will produce libraries or object files in the OMF format.",
            "title": "OMF"
        },
        {
            "location": "/building/windows/#ldc",
            "text": "Older LDC releases for Windows were built on top of  mingw-w64 , but recent releases require the Microsoft tools and libraries. The same COFF instructions in the DMD section above apply here.",
            "title": "LDC"
        },
        {
            "location": "/building/windows/#gdc",
            "text": "There has not been a GDC release for Windows in some time. If there eventually is, it will assumedly be built on top of mingw-w64. In that case, only binaries compiled with mingw-w64, either downloaded in precompiled packages or compiled yourself, will be compatible. While the MinGW linker does support COFF, and can sometimes link with binaries compiled with Visual C++, there are often linker errors that need to be worked around. Best not to mix them.",
            "title": "GDC"
        },
        {
            "location": "/loading/loader/",
            "text": "All Derelict packages have one thing in common. Because each package is a \ndynamic binding\n, it must be loaded at runtime. The interface for this is the same across all packages. The DerelictUtil package contains all of the functionality needed to load a dynamic library at runtime. Each binding contains a loader class that extends from \nSharedLibLoader\n, a class found in \nderelict.util.loader\n. This class exposes two methods for dynamically loading shared libraries.\n\n\nSome of the Derelict packages support a static binding configuration that eliminates the need to use a \nSharedLibLoader\n. Instead, the C library is linked either statically or dynamically when compiling the executable. This page is exclusively about using Derelict packages in the dynamic binding configuration.\n\n\nA normal load\n\u00b6\n\n\nThe method that most developers will use is called \nload\n and takes no arguments. The specific loader on which this method is called will attempt to find and load a shared library, using a predefined set of library names, on the default system shared library path. Loader instances are created automatically in module constructors and, by convention and with few exceptions, are named according to the Derelict package to which they belong. The following example shows how to load the \nSDL library\n via \nDerelictSDL2\n.\n\n\nimport\n \nderelict\n.\nsdl2\n.\nsdl\n;\n\n\n\nvoid\n \nmain\n()\n\n\n{\n\n    \nDerelictSDL2\n.\nload\n();\n\n\n}\n\n\n\n\n\n\nCustom library path\n\u00b6\n\n\nIt is important to understand the system library path for each system an application is intended to support. For example, on Windows the system loader will search for the SDL DLL first in the application directory, then in the current working directory, then in a couple of predefined system directories before falling back on those specified in the \nPATH\n environment variable (see \nMSDN\n for more details). On other platforms, the application directory and current working directory typically are not searched at all (see \nthis page\n for Linux and \nthis one\n for Mac OS X).\n\n\nThe default library names are selected for each Derelict package based on common formats for each operating system. Sometimes, it is necessary to bypass the default names. For example, a developer may decide to ship special copies of a shared library using a non-standard name, or storing them in a subdirectory under the application directory. In such a case, an overload of the \nload\n method should be used. One form accepts an array of strings, each a library name. Another overload takes single string containing a comma-separated list of library names. Each name can include a path. If no path is specified, the default search path will be used.\n\n\nimport\n \nderelict\n.\nsdl2\n.\nsdl\n;\n\n\n\nversion\n \nWindows\n \nlibName\n \n=\n \n\"dlls\\\\MySDL2.dll\"\n;\n\n\nelse\n \nlibName\n \n=\n \n\"MySDL2.so\"\n;\n\n\n\nvoid\n \nmain\n()\n\n\n{\n\n    \nDerelictSDL2\n.\nload\n(\nlibName\n);\n\n\n}\n\n\n\n\n\n\nSharedLibVersion\n\u00b6\n\n\nSome Derelict loaders, but not all, support version-specific loading. In other words, it's possible to tell the loader to attempt to load a lower version of a shared library than the highest version it supports. An example is DerelictFI.\n\n\nDerelictFI is a binding to the \nFreeImage library\n. FreeImage is supported on every major platform. Most Linux distributions make it available through the system package manager, but the version available is always behind the highest version supported by DerelictFI. A program that simply calls \nDerelictFI.load()\n on such systems will fail to load the library.\n\n\nTo work around this, a user can choose the minimum required version of FreeImage. The lowest supported by DerelictFI is \n3.15.0\n. If none of the functions added in later versions of FreeImage are needed, then the call to \nDerelictFI.load\n can be made like so:\n\n\nDerelictFI\n.\nload\n(\nSharedLibVersion\n(\n3\n,\n \n15\n,\n \n0\n));\n\n\n\n\n\n\nCheck the documentation for any Derelict package you use to determine if it supports loading with \nSharedLibVersion\n and, if so, which versions are available as arguments. To future-proof your program, it's a good idea to always use \nSharedLibVersion\n where supported. Simply calling \nload()\n will always attempt to load the highest version supported. If a Derelict package is updated and you release a new version of your app, the app can fail if your users haven't yet updated the library on their system. By always specifying the version of the library that you need, your app will always load newer releases of a library (though you shouldn't expect a \n3.x\n loader to load a \n4.x\n library).",
            "title": "The Derelict Loader"
        },
        {
            "location": "/loading/loader/#a-normal-load",
            "text": "The method that most developers will use is called  load  and takes no arguments. The specific loader on which this method is called will attempt to find and load a shared library, using a predefined set of library names, on the default system shared library path. Loader instances are created automatically in module constructors and, by convention and with few exceptions, are named according to the Derelict package to which they belong. The following example shows how to load the  SDL library  via  DerelictSDL2 .  import   derelict . sdl2 . sdl ;  void   main ()  { \n     DerelictSDL2 . load ();  }",
            "title": "A normal load"
        },
        {
            "location": "/loading/loader/#custom-library-path",
            "text": "It is important to understand the system library path for each system an application is intended to support. For example, on Windows the system loader will search for the SDL DLL first in the application directory, then in the current working directory, then in a couple of predefined system directories before falling back on those specified in the  PATH  environment variable (see  MSDN  for more details). On other platforms, the application directory and current working directory typically are not searched at all (see  this page  for Linux and  this one  for Mac OS X).  The default library names are selected for each Derelict package based on common formats for each operating system. Sometimes, it is necessary to bypass the default names. For example, a developer may decide to ship special copies of a shared library using a non-standard name, or storing them in a subdirectory under the application directory. In such a case, an overload of the  load  method should be used. One form accepts an array of strings, each a library name. Another overload takes single string containing a comma-separated list of library names. Each name can include a path. If no path is specified, the default search path will be used.  import   derelict . sdl2 . sdl ;  version   Windows   libName   =   \"dlls\\\\MySDL2.dll\" ;  else   libName   =   \"MySDL2.so\" ;  void   main ()  { \n     DerelictSDL2 . load ( libName );  }",
            "title": "Custom library path"
        },
        {
            "location": "/loading/loader/#sharedlibversion",
            "text": "Some Derelict loaders, but not all, support version-specific loading. In other words, it's possible to tell the loader to attempt to load a lower version of a shared library than the highest version it supports. An example is DerelictFI.  DerelictFI is a binding to the  FreeImage library . FreeImage is supported on every major platform. Most Linux distributions make it available through the system package manager, but the version available is always behind the highest version supported by DerelictFI. A program that simply calls  DerelictFI.load()  on such systems will fail to load the library.  To work around this, a user can choose the minimum required version of FreeImage. The lowest supported by DerelictFI is  3.15.0 . If none of the functions added in later versions of FreeImage are needed, then the call to  DerelictFI.load  can be made like so:  DerelictFI . load ( SharedLibVersion ( 3 ,   15 ,   0 ));   Check the documentation for any Derelict package you use to determine if it supports loading with  SharedLibVersion  and, if so, which versions are available as arguments. To future-proof your program, it's a good idea to always use  SharedLibVersion  where supported. Simply calling  load()  will always attempt to load the highest version supported. If a Derelict package is updated and you release a new version of your app, the app can fail if your users haven't yet updated the library on their system. By always specifying the version of the library that you need, your app will always load newer releases of a library (though you shouldn't expect a  3.x  loader to load a  4.x  library).",
            "title": "SharedLibVersion"
        },
        {
            "location": "/loading/failure/",
            "text": "Loader Exceptions\n\u00b6\n\n\nWhen a shared library cannot be loaded, the loader will throw a sublcass of \nDerelictException\n, which in turn is a subclass of D's \nException\n. More specifically, a \nSharedLibLoadException\n is thrown when a shared library is not present on the system path, or fails to load into memory for some other reason. A \nSymbolLoadException\n is thrown when a function is not found in the shared library. In each case, the exception contains a system-specific error message provided by the operating system API.\n\n\nWhen given an array of library names, the loader will attempt to load each of them in turn. It will only throw a \nSharedLibLoadException\n when the last library name fails to load. When any given symbol fails to load, loading will be aborted and a \nSymbolLoadException\n thrown immediately. To catch and manipulate any of these excptions, import \nderelict.util.exception\n.\n\n\nIn some cases, it may be desirable that the loader continue and no exception be thrown when a symbol is missing. For example, when a Derelict package has been updated to support the latest version of a C library, but the user wants to continue supporting the older version of the C library. One option is to use \nSharedLibVersion\n with any Derelict loader that supports it. See \nLoading a Shared Library\n for more information. Where \nSharedLibVersion\n is not supported, there are two possibilites. The recommended approach is to continue using the version of the Derelict package that supports the minimally required version of the C library. The other option is to use a library a feature called \nselective symbol loading\n.\n\n\nSelective Symbol Loading\n\u00b6\n\n\nSelective symbol loading is a means of telling a Derelict loader that it is okay to continue loading a library when a specific symbol is missing. Each loader has a \nmissingSymbolCallback\n property which can be set to either a D delegate or function pointer. The signature in both cases is the same. An example usage follows.\n\n\n// This is needed for the return type enum.\n\n\nimport\n \nderelict\n.\nutil\n.\nexception\n \n:\n \nShouldThrow\n;\n\n\n\nimport\n \nderelict\n.\nsdl2\n.\nsdl\n;\n\n\n\nShouldThrow\n \nmyMissingSymCB\n(\n \nstring\n \nsymbolName\n \n)\n\n\n{\n\n    \nif\n(\n \nsymbolName\n \n==\n \n\"SDL2_SomeFuncIDon'tNeed\"\n \n)\n\n    \n{\n\n        \nreturn\n \nShouldThrow\n.\nNo\n;\n\n    \n}\n\n    \nelse\n\n    \n{\n\n        \nreturn\n \nShouldThrow\n.\nYes\n;\n\n    \n}\n\n\n}\n\n\n\nvoid\n \nmain\n()\n\n\n{\n\n    \n// Set the callback *before* calling load\n\n    \nDerelictSDL2\n.\nmissingSymbolCallback\n \n=\n \n&\nmyMissingSymCB\n;\n\n    \nDerelictSDL2\n.\nload\n();\n\n\n}\n\n\n\n\n\n\nThe use of the \nShouldThrow\n enum makes it easier to remember which value to return when implementing the callback. A simple \ntrue\n or \nfalse\n can sometimes be confusing: does \ntrue\n mean throw or don't throw? Because of the enum, \nderelict.util.exception\n must be imported, but there is no confusion.\n\n\nThe important point here is that the callback must be set \nbefore\n calling the \nload\n method. Otherwise, the loader will have no callback to call. Also note that this is a basic example. There is usually more than one function that must be ignored. When using a \nMissingSymbolCallback\n, it is imperative to check the change log for each new version of the bound C library to understand what has changed between versions so that a complete set of symbol names can be covered. The \nSharedLibVersion\n feature, where supported, uses selective symbol loading internally.",
            "title": "Load Failures"
        },
        {
            "location": "/loading/failure/#loader-exceptions",
            "text": "When a shared library cannot be loaded, the loader will throw a sublcass of  DerelictException , which in turn is a subclass of D's  Exception . More specifically, a  SharedLibLoadException  is thrown when a shared library is not present on the system path, or fails to load into memory for some other reason. A  SymbolLoadException  is thrown when a function is not found in the shared library. In each case, the exception contains a system-specific error message provided by the operating system API.  When given an array of library names, the loader will attempt to load each of them in turn. It will only throw a  SharedLibLoadException  when the last library name fails to load. When any given symbol fails to load, loading will be aborted and a  SymbolLoadException  thrown immediately. To catch and manipulate any of these excptions, import  derelict.util.exception .  In some cases, it may be desirable that the loader continue and no exception be thrown when a symbol is missing. For example, when a Derelict package has been updated to support the latest version of a C library, but the user wants to continue supporting the older version of the C library. One option is to use  SharedLibVersion  with any Derelict loader that supports it. See  Loading a Shared Library  for more information. Where  SharedLibVersion  is not supported, there are two possibilites. The recommended approach is to continue using the version of the Derelict package that supports the minimally required version of the C library. The other option is to use a library a feature called  selective symbol loading .",
            "title": "Loader Exceptions"
        },
        {
            "location": "/loading/failure/#selective-symbol-loading",
            "text": "Selective symbol loading is a means of telling a Derelict loader that it is okay to continue loading a library when a specific symbol is missing. Each loader has a  missingSymbolCallback  property which can be set to either a D delegate or function pointer. The signature in both cases is the same. An example usage follows.  // This is needed for the return type enum.  import   derelict . util . exception   :   ShouldThrow ;  import   derelict . sdl2 . sdl ;  ShouldThrow   myMissingSymCB (   string   symbolName   )  { \n     if (   symbolName   ==   \"SDL2_SomeFuncIDon'tNeed\"   ) \n     { \n         return   ShouldThrow . No ; \n     } \n     else \n     { \n         return   ShouldThrow . Yes ; \n     }  }  void   main ()  { \n     // Set the callback *before* calling load \n     DerelictSDL2 . missingSymbolCallback   =   & myMissingSymCB ; \n     DerelictSDL2 . load ();  }   The use of the  ShouldThrow  enum makes it easier to remember which value to return when implementing the callback. A simple  true  or  false  can sometimes be confusing: does  true  mean throw or don't throw? Because of the enum,  derelict.util.exception  must be imported, but there is no confusion.  The important point here is that the callback must be set  before  calling the  load  method. Otherwise, the loader will have no callback to call. Also note that this is a basic example. There is usually more than one function that must be ignored. When using a  MissingSymbolCallback , it is imperative to check the change log for each new version of the bound C library to understand what has changed between versions so that a complete set of symbol names can be covered. The  SharedLibVersion  feature, where supported, uses selective symbol loading internally.",
            "title": "Selective Symbol Loading"
        },
        {
            "location": "/packages/latest-versions/",
            "text": "The following table shows the latest release version of every supported package in the DerelictOrg umbrella, along with the name of the C library to which it binds and name of the primary maintainer. Click on the package name to go to the package-specific documentation (work in progress) for details, the C library names to visit the C project pages, and the maintainer names to visit their GitHub profiles.\n\n\n\n\nNote\n\n\nThe following packages are not currently supported, though they may become so in the future: \nDerelictAllegro5\n, \nDerelictCEF\n, \nDerelictGLES\n.\n\n\n\n\n\n\n\n\n\n\nPackage\n\n\nLatest Version\n\n\nC Library\n\n\nMaintainer\n\n\n\n\n\n\n\n\n\n\nDerelictAL\n\n\n2.0.0-beta.1\n\n\nOpenAL\n\n\nMike Parker\n\n\n\n\n\n\nDerelictALURE\n\n\n2.0.0-beta.1\n\n\nALURE (AL Utilities REtooled)\n\n\nMike Parker\n\n\n\n\n\n\nDerelictASSIMP3\n\n\n2.0.0-beta.1\n\n\nASSIMP (Open Asset Import Library)\n\n\nMike Parker\n\n\n\n\n\n\nDerelictBgfx\n\n\n8.1.0\n\n\nbgfx\n\n\nGuillaume Piolat\n\n\n\n\n\n\nDerelictCL\n\n\n3.1.0\n\n\nOpenCL\n\n\nGuillaume Piolat\n\n\n\n\n\n\nDerelictCUDA\n\n\n3.1.0\n\n\nCUDA\n\n\nGuillaume Piolat\n\n\n\n\n\n\nDerelictENet\n\n\n4.1.0\n\n\nENet\n\n\nGuillaume Piolat\n\n\n\n\n\n\nDerelictFI\n\n\n3.0.0-beta.1\n\n\nFreeImage\n\n\nMike Parker\n\n\n\n\n\n\nDerelictFT\n\n\n2.0.0-beta.1\n\n\nFreeType\n\n\nMike Parker\n\n\n\n\n\n\nDerelictGL3\n\n\n2.0.0-beta.1\n\n\nOpenGL\n\n\nMike Parker\n\n\n\n\n\n\nDerelictGLFW3\n\n\n4.0.0-beta.1\n\n\nGLFW\n\n\nMike Parker\n\n\n\n\n\n\nDerelictIL\n\n\n2.0.0-beta.1\n\n\nDevIL\n\n\nMike Parker\n\n\n\n\n\n\nDerelictLua\n\n\n2.0.0-beta.1\n\n\nLua\n\n\nMike Parker\n\n\n\n\n\n\nDerelictODE\n\n\n3.0.0-beta.1\n\n\nODE (Open Dynamics Engine)\n\n\nMike Parker\n\n\n\n\n\n\nDerelictOgg\n\n\n2.0.0-beta.1\n\n\nlibogg\n\n\nMike Parker\n\n\n\n\n\n\nDerelictPHYSFS\n\n\n3.0.0-beta.1\n\n\nPhysicsFS\n\n\nMike Parker\n\n\n\n\n\n\nDerelictPQ\n\n\n3.0.0-beta.2\n\n\nlibpq\n\n\nMike Parker\n\n\n\n\n\n\nDerelictSDL2\n\n\n3.0.0-beta.2\n\n\nSDL (Simple DirectMedia Layer)\n\n\nMike Parker\n\n\n\n\n\n\nDerelictSFML2\n\n\n4.0.0-beta.1\n\n\nSFML\n\n\nMike Parker\n\n\n\n\n\n\nDerelictTheora\n\n\n2.0.0-beta.1\n\n\nlibtheora\n\n\nMike Parker\n\n\n\n\n\n\nDerelictUtil\n\n\n3.0.0-beta.1\n\n\nn/a\n\n\nMike Parker\n\n\n\n\n\n\nDerelictVorbis\n\n\n2.0.0-beta.1\n\n\nlibvorbis\n\n\nMike Parker",
            "title": "Latest Versions"
        },
        {
            "location": "/packages/gl3/",
            "text": "DerelictGL3 is a dynamic binding to the \nOpenGL\n library.\n\n\nDue to the nature of OpenGL, this package differs from other Derelict packages in a few ways. These differences are described in the relevant sections below.\n\n\nReleases\n\u00b6\n\n\nThe DUB package name of DerelictGL3 is \nderelict-gl3\n.\n\n\nThe current DUB package version is \n~>2.0.0-beta\n.\n\n\nUnlike other Derelict packages, DerelictGL3 releases do not correspond to any specific version of the C library. All versions of OpenGL are always supported, even though the \nSharedLibVersion\n construct is not. When a new version of OpenGL is released, support is added to the current DerelictGL3 release series and the patch number, rather than the minor number, is bumped in the new release version.\n\n\n\n\n\n\n\n\nDerelictGL3 Version\n\n\ngit Branch\n\n\nOpenGL Version\n\n\nDerelictUtil Version\n\n\nSupported\n\n\n\n\n\n\n\n\n\n\n2.0.0-beta.1\n\n\nmaster\n/\n2.0\n\n\n3.2.x\n\n\n3.0.x\n\n\n\u2714\n\n\n\n\n\n\n1.0.x\n\n\n1.0\n\n\n1.0 - 4.5\n\n\n1.0.x - 3.0.x\n\n\n\u2714\n\n\n\n\n\n\n\n\nThe \n1.0.x\n series is compatible with all DerelictUtil versions, as long as it is compiled against and linked with the same version of DerelictUtil as an executable. Unfortunately, in a oversight lost to time, the \n1.0.x\n series uses a \nderelict-util\n dependency of \n>=1.0.3\n which disallows anything less than version \n1.0.3\n, but has no contraint on later versions. As such, it's possible to independently compile the DerelictGL3 library against version \n1.0.x\n or \n2.0.x\n of DerelictUtil, then attempt to link with DerelictUtil \n3.0.x\n when building the executable.\n\n\nIt's recommended to use DerelictGL3 \n1.0.x\n only when you need compatibility with the \n2.0.x\n series of DerelictUtil because of other Derelict packages. If you compile DerelictGL3 \n1.0.x\n independently, make sure you specify version \n2.0.x\n of DerelictUtil in your \ndub.selections.json\n file. Otherwise, DUB will pull down the latest DerelictUtil and link against it.\n\n\nDerelictGL3 \n3.0.x\n was overhauled to provide compile-time configuration of supported OpenGL versions and extensions. It also provides the option of wrapping all function declarations in a \nstruct\n, either automatically or in a custom type, to provide more efficient context management. All new projects should use this version. Support for the \n1.0.x\n series will be discontinued at some point in the future.\n\n\nUsing DerelictGL3\n\u00b6\n\n\nSee the generic documentation on \nCompiling and Linking\n for generic information on incorporating any Derelict package in your project.\n\n\nObtaining the binaries\n\u00b6\n\n\nOpenGL is available on Windows and Mac OS X out of the box. Windows users should upgrade their graphics card drivers to always have the latest version. Linux and *BSD users should consult their OS knowlege base or support forums to determine enable hardware-accelerated OpenGL.\n\n\nConfiguring OpenGL versions\n\u00b6\n\n\nOut of the box, DerelictGL3 will attempt to load all available OpenGL versions as free functions, i.e. not wrapped in a struct. This can be overridden by adding a \nversions\n directive to a project's DUB configuration with one of the following values.\n\n\n\n\nDerelictGL3_CustomFreeFuncs\n\n\n\n\nWhen this version is specified, the DerelictGL3 modules will not declare any types or function pointers. This must be handled by the user using a mixin template, \nglFreeFuncs\n. The following enables OpenGL versions 3.3 and lower:\n\n\nmodule\n \nmygl\n;\n\n\npublic\n \nimport\n \nderelict\n.\nopengl\n;\n\n\nmixin\n \nglFreeFuncs\n!(\nGLVersion\n.\ngl33\n);\n\n\n\n\n\n\nThis will enable all of the OpenGL types and function pointers for every version up to OpenGL 3.3 into the \nmygl\n module. Modules that need to call OpenGL functions should import \nmygl\n.\n\n\nglFreeFuncs\n takes an optional parameter that will include deprecated types and function pointer declarations. This is \nfalse\n by default, but can be enabled with, e.g., \nmixin glFreeFuncs(GLVersion.gl33, true);\n.\n\n\nWith no arguments, \nglFreeFuncs\n will enable all supported versions of OpenGL without deprecations. This is the default behavior.\n\n\n\n\nDerelictGL3_Contexts\n\n\n\n\nThis will configure DerelictGL3 to load the OpenGL function pointers into a \nstruct\n. To use the default implementation, mixin the \nglContext\n template along with the desired version:\n\n\nmodule\n \nmygl\n;\n\n\npublic\n \nimport\n \nderelict\n.\nopengl\n;\n\n\nmixin\n \nglContext\n!(\nGLVersion\n.\ngl33\n);\n\n\nGLContext\n \ncontext\n;\n\n\n\n\n\n\nThis will enable all of the types and function pointers for every version up to OpenGL 3.3 into the \nmygl\n module, wrapping the function pointers (but not the types) into a structure named \nGLContext\n, and create an instance of that type named \ncontext\n. OpenGL functions can then be called via the \ncontext\n instance, e.g. \ncontext.glClear(GL_COLOR_BUFFER_BIT);\n.\n\n\nDeprecated types and functions can be enabled by passing \ntrue\n as a second argument to \nglContext\n. With no arguments, \nglContext\n will load all supported versions of OpenGL without deprecations (the default behavior).\n\n\nCustom contexts are also supported, but they require a bit of string and template \nmixin\n boilerplate.\n\n\nmodule\n \nmygl\n;\n\n\npublic\n \nimport\n \nderelict\n.\nopengl\n;\n\n\n\nenum\n \nmaxGLVersion\n \n=\n \nGLVersion\n.\ngl33\n;\n\n\nenum\n \nsupportDeprecated\n \n=\n \nfalse\n;\n\n\n\n// Required imports\n\n\nstatic\n \nif\n(!\nsupportDeprecated\n)\n \nmixin\n(\nglImports\n);\n\n\nelse\n \nmixin\n(\ngl_depImports\n);\n\n\n\n// Type declarations should be outside of the struct\n\n\nmixin\n \nglDecls\n!(\nmaxGLVersion\n,\n \nsupportDeprecated\n);\n\n\nstruct\n \nMyContext\n \n{\n\n    \nmixin\n \nglFuncs\n!(\nmaxGLVersion\n,\n \nsupportDeprecated\n);\n\n    \nmixin\n \nglLoaders\n!(\nmaxGLVersion\n,\n \nsupportDeprecated\n);\n\n\n}\n\n\nMyContext\n \ncontext\n;\n\n\n\n\n\n\nThis is essentially what is done by the default \nglContext\n mixin. Note that in \nglDecls\n, \nglFuncs\n, and \nglLoaders\n, the second parameter is optional, with the default value of \nfalse\n.\n\n\nLoading the OpenGL library\n\u00b6\n\n\nThe steps required to gain access to different OpenGL versions may differ across operating systems. For example, on Windows OpenGL versions up to 1.1 may be dynamically linked, but 1.2 and above must be loaded dynamically at runtime after a context has been created. On Mac OS X, all of the OpenGL versions may be dynamically linked or dynamically loaded, and in the latter case a context need not be active.\n\n\nTo hide these differences and present a unified interface on all supported platform, DerelictGL3 requires a three-step process. When using the free function configuration, those steps are:\n\n\n\n\nCall \nDerelictGL3.load\n.\n \nThis must be done before any OpenGL functions are called, but may happen before or after a context has been created, but must be done before calling \nDerelictGL3.reload\n in the last step. This will load the OpenGL shared library and all OpenGL functions up to version 1.1. Failure to load will result in an exception.\n\n\nCreate an OpenGL context.\n \nThis may occur before or after \nDerelictGL3.load\n is called, but must be done before calling \nDerelictGL3.reload\n in the next step. DerelictGL3 does not provide the means of creating an OpenGL context. For that, use either the system API (like Win32) or a third-party library such as \nSDL\n, \nGLFW\n, or \nSFML\n.\n\n\nCall \nDerelictGL3.reload\n.\n\nThis must occur after \nDerelictGL3.load\n as been called and after an OpenGL context has been created. This will load all versions that have been configured from 1.2 and up, as well as any configured extensions. For maximum portability, this function should be called every time the OpenGL context is changed.\n\n\n\n\nThe following example demonstrates. It uses the default DerelictGL3 free function configuration. It does not show the code to create the context.\n\n\nimport\n \nderelict\n.\nopengl\n;\n\n\nvoid\n \nmain\n()\n \n{\n\n    \n// Load the OpenGL shared library\n\n    \nDerelictGL3\n.\nload\n();\n\n\n    \n// Create the context using a system or third-party API\n\n    \nmyCreateContext\n();\n\n\n    \n// Now load all supported functions\n\n    \nDerelictGL3\n.\nreload\n();\n\n\n}\n\n\n\n\n\n\nThe steps are similar when using the context object configuration.\n\n\n\n\nCall \nDerelictGL3.load\n.\n \nThis must be done before any OpenGL functions are called, but may happen before or after a context has been created, but must be done before calling \nload\n on a context object in the last step. This will load the OpenGL shared library but does not load any OpenGL functions. Failure to load will result in an exception.\n\n\nCreate an OpenGL context.\n \nThis may occur before or after \nDerelictGL3.load\n is called, but must be done before calling \nload\n on a context object in the next step. DerelictGL3 does not provide the means of creating an OpenGL context. For that, use either the system API (like Win32) or a third-party library such as \nSDL\n, \nGLFW\n, or \nSFML\n.\n\n\nCall \nload\n on a context object instance.\n\nThis must occur after \nDerelictGL3.load\n as been called and after an OpenGL context has been created. For maximum portability, context objects should be created for and associated with each OpenGL context used in the program. Then, the \nload\n method can be called on each instance just once. This will load all configured OpenGL functions from 1.0 and up and any extensions that have been configured. When the OpenGL context changes, functions can be called through its associated object instance.\n\n\n\n\nThe following examples demonstrates, using the default \nGLContext\n type.\n\n\nimport\n \nderelict\n.\nopengl\n;\n\n\nmixin\n \nglContext\n!(\nGLVersion\n.\ngl33\n);\n\n\nGLContext\n \nmyContext\n;\n\n\n\nvoid\n \nmain\n()\n \n{\n\n    \n// Load the OpenGL shared library\n\n    \nDerelictGL3\n.\nload\n();\n\n\n    \n// Create the context using a system or third-party API\n\n    \nmyCreateContext\n();\n\n\n    \n// Now load all supported functions\n\n    \nmyContext\n.\nload\n();\n\n\n}\n\n\n\n\n\n\nBoth \nDerelictGL3.reload\n and the \nload\n method of a context instance return the highest version of OpenGL that was sucessfully loaded in the form of a \nGLVersion\n value. You can also obtain the same value by calling calling \nloadedVersion\n on the \nDerelictGL3\n instance or on the context object.\n\n\nThe following loads the highest supported version, but requires OpenGL 3.3 at a minimum.\n\n\nimport\n \nderelict\n.\nopengl\n;\n\n\nvoid\n \nmain\n()\n \n{\n\n    \nDerelictGL3\n.\nload\n();\n\n    \nmyCreateContext\n();\n\n    \nauto\n \nloaded\n \n=\n \nDerelictGL3\n.\nreload\n();\n\n    \nif\n(\nloaded\n \n<\n \nGLVersion\n.\ngl33\n)\n \n{\n\n        \nthrow\n \nnew\n \nException\n(\n\"OpenGL version too low!\"\n);\n\n    \n}\n\n\n}\n\n\n\n\n\n\nExtensions\n\u00b6\n\n\nWhether using the default configuration or a custom one, no extensions are loaded by default. Extensions must be individually declared using string mixins unless they are part of the core specification of an OpenGL version you have configured.\n\n\n\n\nNote\n\n\nTo see which extensions are loaded along with the core versions, see the \ncore_*.d\n files in the DerelictGL3 source directory \nsource/derelict/opengl/extensions\n. Eventually, they will all be listed in this document.\n\n\n\n\nTo demonstrate, let's assume you want to enable the highest OpenGL version available and you want to make use of the OpenGL 4.3 function \nglMultiDrawArraysIndirect\n. This function is part of the \nGL_ARB_multi_draw_indirect\n extension.\n\n\nimport\n \nderelict\n.\nopengl\n;\n\n\n\nbool\n \nhasMultiDrawIndirect\n;\n\n\n\nvoid\n \nmain\n()\n \n{\n\n    \nDerelictGL3\n.\nload\n();\n\n    \nmyCreateContext\n();\n\n    \nauto\n \nloaded\n \n=\n \nDerelictGL3\n.\nreload\n();\n\n    \nhasMultiDrawIndirect\n \n=\n \n(\nloaded\n \n>=\n \nGLVersion\n.\ngl43\n)\n \n        \n||\n \nDerelictGL3\n.\nisExtensionLoaded\n(\n\"GL_ARB_multi_draw_indirect\"\n);\n\n\n}\n \n\n\n\n\n\nisExtensionLoaded\n is also available on context objects, e.g. \nmyContext.isExtensionLoaded(extName);\n.\n\n\nWhen you are using an extension that has not been promoted to core, or you have configured DerelictGL3 to use a version lower than the one in which the extension was promoted, you must declare the extension. For the free function API, this is a one liner. For example, if you've configured OpenGL 4.1 as the highest version, but want to support the \nGL_ARB_multidraw_indirect\n extension:\n\n\nimport\n \nderelict\n.\nopengl\n;\n\n\nmixin\n \nglFreeFuncs\n!(\nGLVersion\n.\ngl41\n);\n\n\n\n// GL_ARB_multi_draw_indrect type and function pointer declarations\n\n\nmixin\n(\narbMultiDrawIndirect\n);\n\n\n\nbool\n \nhasMultiDrawIndirect\n;\n\n\n\nvoid\n \nmain\n()\n \n{\n\n    \nDerelictGL3\n.\nload\n();\n\n    \nmyCreateContext\n();\n\n    \nDerelictGL3\n.\nreload\n();\n\n    \nhasMultiDrawIndirect\n \n=\n \n            \nDerelictGL3\n.\nisExtensionLoaded\n(\n\"GL_ARB_multi_draw_indirect\"\n);\n\n\n}\n\n\n\n\n\n\nTo use extensions with context objects, you must define a custom context type. It is not currently possible to mix extension in to the default \nGLContext\n. Each extension declaration must be split into three parts: types, functions, and the loader.\n\n\nmodule\n \nmygl\n;\n\n\npublic\n \nimport\n \nderelict\n.\nopengl\n;\n\n\n\nenum\n \nmaxGLVersion\n \n=\n \nGLVersion\n.\ngl41\n;\n\n\nenum\n \nsupportDeprecated\n \n=\n \nfalse\n;\n\n\n\n// Required imports\n\n\nstatic\n \nif\n(!\nsupportDeprecated\n)\n \nmixin\n(\nglImports\n);\n\n\nelse\n \nmixin\n(\ngl_depImports\n);\n\n\n\n// Core type declarations\n\n\nmixin\n \nglDecls\n!(\nmaxGLVersion\n,\n \nsupportDeprecated\n);\n\n\n\n// Extension type declarations\n\n\nmixin\n(\narbMultiDrawIndirectDecls\n);\n\n\n\nstruct\n \nMyContext\n \n{\n\n    \n// Core functions\n\n    \nmixin\n \nglFuncs\n!(\nmaxGLVersion\n,\n \nsupportDeprecated\n);\n\n\n    \n// Extension functions\n\n    \nmixin\n(\narbMultiDrawIndirectFuncs\n);\n\n\n    \n// Core loaders\n\n    \nmixin\n \nglLoaders\n!(\nmaxGLVersion\n,\n \nsupportDeprecated\n);\n\n\n    \n// Extension loaders\n\n    \nmixin\n(\narbMultiDrawIndirectLoaders\n);\n\n\n}\n\n\n\nMyContext\n \ncontext\n;\n\n\n\n\n\n\nWith this, after \nDerelictGL3.load\n has been called and a context created, then calling \ncontext.load()\n will load any mixed in extensions that are available. Then \ncontext.isExtensionLoaded\n can be called to test for availability.",
            "title": "DerelictGL3"
        },
        {
            "location": "/packages/gl3/#releases",
            "text": "The DUB package name of DerelictGL3 is  derelict-gl3 .  The current DUB package version is  ~>2.0.0-beta .  Unlike other Derelict packages, DerelictGL3 releases do not correspond to any specific version of the C library. All versions of OpenGL are always supported, even though the  SharedLibVersion  construct is not. When a new version of OpenGL is released, support is added to the current DerelictGL3 release series and the patch number, rather than the minor number, is bumped in the new release version.     DerelictGL3 Version  git Branch  OpenGL Version  DerelictUtil Version  Supported      2.0.0-beta.1  master / 2.0  3.2.x  3.0.x  \u2714    1.0.x  1.0  1.0 - 4.5  1.0.x - 3.0.x  \u2714     The  1.0.x  series is compatible with all DerelictUtil versions, as long as it is compiled against and linked with the same version of DerelictUtil as an executable. Unfortunately, in a oversight lost to time, the  1.0.x  series uses a  derelict-util  dependency of  >=1.0.3  which disallows anything less than version  1.0.3 , but has no contraint on later versions. As such, it's possible to independently compile the DerelictGL3 library against version  1.0.x  or  2.0.x  of DerelictUtil, then attempt to link with DerelictUtil  3.0.x  when building the executable.  It's recommended to use DerelictGL3  1.0.x  only when you need compatibility with the  2.0.x  series of DerelictUtil because of other Derelict packages. If you compile DerelictGL3  1.0.x  independently, make sure you specify version  2.0.x  of DerelictUtil in your  dub.selections.json  file. Otherwise, DUB will pull down the latest DerelictUtil and link against it.  DerelictGL3  3.0.x  was overhauled to provide compile-time configuration of supported OpenGL versions and extensions. It also provides the option of wrapping all function declarations in a  struct , either automatically or in a custom type, to provide more efficient context management. All new projects should use this version. Support for the  1.0.x  series will be discontinued at some point in the future.",
            "title": "Releases"
        },
        {
            "location": "/packages/gl3/#using-derelictgl3",
            "text": "See the generic documentation on  Compiling and Linking  for generic information on incorporating any Derelict package in your project.",
            "title": "Using DerelictGL3"
        },
        {
            "location": "/packages/gl3/#obtaining-the-binaries",
            "text": "OpenGL is available on Windows and Mac OS X out of the box. Windows users should upgrade their graphics card drivers to always have the latest version. Linux and *BSD users should consult their OS knowlege base or support forums to determine enable hardware-accelerated OpenGL.",
            "title": "Obtaining the binaries"
        },
        {
            "location": "/packages/gl3/#configuring-opengl-versions",
            "text": "Out of the box, DerelictGL3 will attempt to load all available OpenGL versions as free functions, i.e. not wrapped in a struct. This can be overridden by adding a  versions  directive to a project's DUB configuration with one of the following values.   DerelictGL3_CustomFreeFuncs   When this version is specified, the DerelictGL3 modules will not declare any types or function pointers. This must be handled by the user using a mixin template,  glFreeFuncs . The following enables OpenGL versions 3.3 and lower:  module   mygl ;  public   import   derelict . opengl ;  mixin   glFreeFuncs !( GLVersion . gl33 );   This will enable all of the OpenGL types and function pointers for every version up to OpenGL 3.3 into the  mygl  module. Modules that need to call OpenGL functions should import  mygl .  glFreeFuncs  takes an optional parameter that will include deprecated types and function pointer declarations. This is  false  by default, but can be enabled with, e.g.,  mixin glFreeFuncs(GLVersion.gl33, true); .  With no arguments,  glFreeFuncs  will enable all supported versions of OpenGL without deprecations. This is the default behavior.   DerelictGL3_Contexts   This will configure DerelictGL3 to load the OpenGL function pointers into a  struct . To use the default implementation, mixin the  glContext  template along with the desired version:  module   mygl ;  public   import   derelict . opengl ;  mixin   glContext !( GLVersion . gl33 );  GLContext   context ;   This will enable all of the types and function pointers for every version up to OpenGL 3.3 into the  mygl  module, wrapping the function pointers (but not the types) into a structure named  GLContext , and create an instance of that type named  context . OpenGL functions can then be called via the  context  instance, e.g.  context.glClear(GL_COLOR_BUFFER_BIT); .  Deprecated types and functions can be enabled by passing  true  as a second argument to  glContext . With no arguments,  glContext  will load all supported versions of OpenGL without deprecations (the default behavior).  Custom contexts are also supported, but they require a bit of string and template  mixin  boilerplate.  module   mygl ;  public   import   derelict . opengl ;  enum   maxGLVersion   =   GLVersion . gl33 ;  enum   supportDeprecated   =   false ;  // Required imports  static   if (! supportDeprecated )   mixin ( glImports );  else   mixin ( gl_depImports );  // Type declarations should be outside of the struct  mixin   glDecls !( maxGLVersion ,   supportDeprecated );  struct   MyContext   { \n     mixin   glFuncs !( maxGLVersion ,   supportDeprecated ); \n     mixin   glLoaders !( maxGLVersion ,   supportDeprecated );  }  MyContext   context ;   This is essentially what is done by the default  glContext  mixin. Note that in  glDecls ,  glFuncs , and  glLoaders , the second parameter is optional, with the default value of  false .",
            "title": "Configuring OpenGL versions"
        },
        {
            "location": "/packages/gl3/#loading-the-opengl-library",
            "text": "The steps required to gain access to different OpenGL versions may differ across operating systems. For example, on Windows OpenGL versions up to 1.1 may be dynamically linked, but 1.2 and above must be loaded dynamically at runtime after a context has been created. On Mac OS X, all of the OpenGL versions may be dynamically linked or dynamically loaded, and in the latter case a context need not be active.  To hide these differences and present a unified interface on all supported platform, DerelictGL3 requires a three-step process. When using the free function configuration, those steps are:   Call  DerelictGL3.load .  \nThis must be done before any OpenGL functions are called, but may happen before or after a context has been created, but must be done before calling  DerelictGL3.reload  in the last step. This will load the OpenGL shared library and all OpenGL functions up to version 1.1. Failure to load will result in an exception.  Create an OpenGL context.  \nThis may occur before or after  DerelictGL3.load  is called, but must be done before calling  DerelictGL3.reload  in the next step. DerelictGL3 does not provide the means of creating an OpenGL context. For that, use either the system API (like Win32) or a third-party library such as  SDL ,  GLFW , or  SFML .  Call  DerelictGL3.reload . \nThis must occur after  DerelictGL3.load  as been called and after an OpenGL context has been created. This will load all versions that have been configured from 1.2 and up, as well as any configured extensions. For maximum portability, this function should be called every time the OpenGL context is changed.   The following example demonstrates. It uses the default DerelictGL3 free function configuration. It does not show the code to create the context.  import   derelict . opengl ;  void   main ()   { \n     // Load the OpenGL shared library \n     DerelictGL3 . load (); \n\n     // Create the context using a system or third-party API \n     myCreateContext (); \n\n     // Now load all supported functions \n     DerelictGL3 . reload ();  }   The steps are similar when using the context object configuration.   Call  DerelictGL3.load .  \nThis must be done before any OpenGL functions are called, but may happen before or after a context has been created, but must be done before calling  load  on a context object in the last step. This will load the OpenGL shared library but does not load any OpenGL functions. Failure to load will result in an exception.  Create an OpenGL context.  \nThis may occur before or after  DerelictGL3.load  is called, but must be done before calling  load  on a context object in the next step. DerelictGL3 does not provide the means of creating an OpenGL context. For that, use either the system API (like Win32) or a third-party library such as  SDL ,  GLFW , or  SFML .  Call  load  on a context object instance. \nThis must occur after  DerelictGL3.load  as been called and after an OpenGL context has been created. For maximum portability, context objects should be created for and associated with each OpenGL context used in the program. Then, the  load  method can be called on each instance just once. This will load all configured OpenGL functions from 1.0 and up and any extensions that have been configured. When the OpenGL context changes, functions can be called through its associated object instance.   The following examples demonstrates, using the default  GLContext  type.  import   derelict . opengl ;  mixin   glContext !( GLVersion . gl33 );  GLContext   myContext ;  void   main ()   { \n     // Load the OpenGL shared library \n     DerelictGL3 . load (); \n\n     // Create the context using a system or third-party API \n     myCreateContext (); \n\n     // Now load all supported functions \n     myContext . load ();  }   Both  DerelictGL3.reload  and the  load  method of a context instance return the highest version of OpenGL that was sucessfully loaded in the form of a  GLVersion  value. You can also obtain the same value by calling calling  loadedVersion  on the  DerelictGL3  instance or on the context object.  The following loads the highest supported version, but requires OpenGL 3.3 at a minimum.  import   derelict . opengl ;  void   main ()   { \n     DerelictGL3 . load (); \n     myCreateContext (); \n     auto   loaded   =   DerelictGL3 . reload (); \n     if ( loaded   <   GLVersion . gl33 )   { \n         throw   new   Exception ( \"OpenGL version too low!\" ); \n     }  }",
            "title": "Loading the OpenGL library"
        },
        {
            "location": "/packages/gl3/#extensions",
            "text": "Whether using the default configuration or a custom one, no extensions are loaded by default. Extensions must be individually declared using string mixins unless they are part of the core specification of an OpenGL version you have configured.   Note  To see which extensions are loaded along with the core versions, see the  core_*.d  files in the DerelictGL3 source directory  source/derelict/opengl/extensions . Eventually, they will all be listed in this document.   To demonstrate, let's assume you want to enable the highest OpenGL version available and you want to make use of the OpenGL 4.3 function  glMultiDrawArraysIndirect . This function is part of the  GL_ARB_multi_draw_indirect  extension.  import   derelict . opengl ;  bool   hasMultiDrawIndirect ;  void   main ()   { \n     DerelictGL3 . load (); \n     myCreateContext (); \n     auto   loaded   =   DerelictGL3 . reload (); \n     hasMultiDrawIndirect   =   ( loaded   >=   GLVersion . gl43 )  \n         ||   DerelictGL3 . isExtensionLoaded ( \"GL_ARB_multi_draw_indirect\" );  }    isExtensionLoaded  is also available on context objects, e.g.  myContext.isExtensionLoaded(extName); .  When you are using an extension that has not been promoted to core, or you have configured DerelictGL3 to use a version lower than the one in which the extension was promoted, you must declare the extension. For the free function API, this is a one liner. For example, if you've configured OpenGL 4.1 as the highest version, but want to support the  GL_ARB_multidraw_indirect  extension:  import   derelict . opengl ;  mixin   glFreeFuncs !( GLVersion . gl41 );  // GL_ARB_multi_draw_indrect type and function pointer declarations  mixin ( arbMultiDrawIndirect );  bool   hasMultiDrawIndirect ;  void   main ()   { \n     DerelictGL3 . load (); \n     myCreateContext (); \n     DerelictGL3 . reload (); \n     hasMultiDrawIndirect   =  \n             DerelictGL3 . isExtensionLoaded ( \"GL_ARB_multi_draw_indirect\" );  }   To use extensions with context objects, you must define a custom context type. It is not currently possible to mix extension in to the default  GLContext . Each extension declaration must be split into three parts: types, functions, and the loader.  module   mygl ;  public   import   derelict . opengl ;  enum   maxGLVersion   =   GLVersion . gl41 ;  enum   supportDeprecated   =   false ;  // Required imports  static   if (! supportDeprecated )   mixin ( glImports );  else   mixin ( gl_depImports );  // Core type declarations  mixin   glDecls !( maxGLVersion ,   supportDeprecated );  // Extension type declarations  mixin ( arbMultiDrawIndirectDecls );  struct   MyContext   { \n     // Core functions \n     mixin   glFuncs !( maxGLVersion ,   supportDeprecated ); \n\n     // Extension functions \n     mixin ( arbMultiDrawIndirectFuncs ); \n\n     // Core loaders \n     mixin   glLoaders !( maxGLVersion ,   supportDeprecated ); \n\n     // Extension loaders \n     mixin ( arbMultiDrawIndirectLoaders );  }  MyContext   context ;   With this, after  DerelictGL3.load  has been called and a context created, then calling  context.load()  will load any mixed in extensions that are available. Then  context.isExtensionLoaded  can be called to test for availability.",
            "title": "Extensions"
        },
        {
            "location": "/packages/glfw3/",
            "text": "DerelictGLFW3 provides both \nstatic and dynamic bindings\n to the \nGLFW\n library.\n\n\nReleases\n\u00b6\n\n\nThe DUB package name of DerelictGLFW3 is \nderelict-glfw3\n.\n\n\nThe current DUB package version is \n~>4.0.0-beta\n.\n\n\nThe following table shows the correlation between DerelictGLFW3 releases (the most recent patch release of each \nmajor.minor\n series), its corresponding git branch, GLFW versions, and DerelictUtil versions. The latest release is listed at the top and is the recommended version. When using DerelictGLFW3 with other Derelict packages, please ensure all of the Derelict packages use the same DerelictUtil \nmajor.minor\n series.\n\n\n\n\n\n\n\n\nDerelictGLFW3 Version\n\n\ngit Branch\n\n\nGLFW Version\n\n\nDerelictUtil Version\n\n\nSupported\n\n\n\n\n\n\n\n\n\n\n4.0.0-beta.1\n\n\nmaster\n/\n4.0\n\n\n3.2.x\n\n\n3.0.x\n\n\n\u2714\n\n\n\n\n\n\n3.1.3\n\n\n3.2\n\n\n3.2.x\n\n\n2.0.x\n\n\n\u2714 (bugfix only)\n\n\n\n\n\n\n3.0.1\n\n\n3.1\n\n\n3.2.x\n\n\n2.0.x\n\n\n\u2716\n\n\n\n\n\n\n2.0.0\n\n\n3.0\n\n\n3.1.x\n\n\n2.0.x\n\n\n\u2716\n\n\n\n\n\n\n1.1.1\n\n\nn/a\n\n\n3.1.x\n\n\n1.0.x\n\n\n\u2716\n\n\n\n\n\n\n1.0.2\n\n\nn/a\n\n\n3.0.x\n\n\n1.0.x\n\n\n\u2716\n\n\n\n\n\n\n\n\nAll new development happens on the master branch. Pull requests and issues reported on unsupported branches will be ignored. Both the 4.0.x series and the 3.1.x series support the static binding configuration, but the 3.1.x series should be preferred only for compatibility with other Derelict packages that require DerelictUtil 2.0.x.\n\n\nUsing DerelictGLFW3\n\u00b6\n\n\nSee the generic documentation on [Compiling and Linuking] for generic information on incorporating any Derelict package in your project.\n\n\nObtaining the GLFW binaries\n\u00b6\n\n\nPrecompiled binaries for Windows can be downloaded from the \nGLFW download page\n. The zip archive contains binaries for MinGW, and Visual Studio 2012, 2013, and 2015. When using the dynamic binding configuration, any of the DLLs from this archive can be loaded at runtime. When using the static binding configuration, only the Visual Studio binaries should be used. To link statically, use \nglfw3.lib\n. To link dynamically, use \nglfw3dll.lib\n and distribute the corresponding DLL with your executable. See the documentation on \nWindows-specific compilation\n for more details.\n\n\nWindows binaries for Visual Studio are also available via \nNuGet\n and \nvcpkg\n.\n\n\nBinaries Mac OS X can be obtained through \nHomebrew\n or \nMacPorts\n, though they may not always be the latest release.\n\n\nBinaries for other systems can be obtained through the system package manager.\n\n\nThe GLFW source can be downloaded from the download page or cloned from the \nGLFW GitHub repository\n.\n\n\nChoosing the configuration\n\u00b6\n\n\nBy default, DerelictGLFW3 will be configured as a dynamic binding. There are two ways to enable the static binding configuration. The recommended way is to add a \nsubConfiguration\n entry to your project configuration with the value \nderelict-glfw3-static\n and the appropriate library, as in the following examples. Note that the example assumes linking dynamically, using the precompiled binaries from the GLFW website on Windows. In other binary distributions on Windows, the dynamic import library may simply be named \nglfw3.lib\n instead. In that case, a single \nlibs\n entry with no platform suffix will suffice.  \n\n\ndub.json\n\n\n\"dependencies\"\n:\n \n{\n\n    \n\"derelict-glfw3\"\n:\n \n\"~>4.0.0-beta\"\n\n\n}\n,\n\n\n\"subConfigurations\"\n:\n \n{\n\n    \n\"derelict-glfw3\"\n:\n \n\"derelict-glfw3-static\"\n\n\n}\n,\n\n\n\"libs-windows\"\n:\n \n{\n\n    \n\"glfw3dll\"\n\n\n}\n,\n\n\n\"libs-posix\"\n:\n \n{\n\n    \n\"glfw3\"\n\n\n}\n\n\n\n\n\n\ndub.sdl\n\n\ndependency \n\"derelict-glfw3\"\n \n\"~>4.0.0-beta\"\n\nsubConfiguration \n\"derelict-glfw3\"\n \n\"derelict-glfw3-static\"\n\nlibs \n\"glfw3dll\"\n \nplatform\n=\n\"windows\"\n\nlibs \n\"glfw3\"\n \nplatform\n=\n\"posix\"\n\n\n\n\n\n\nThe alternative is to replace the \nsubConfiguration\n with a \nversions\n entry and give it one of two values, either \nDerelict_Static\n or \nDerelictGLFW3_Static\n. The former will enable the static binding configuration of any other Derelict packages in your project that support it. The latter will enable it only for DerelictGLFW3.\n\n\ndub.json\n\n\n\"dependencies\"\n:\n \n{\n\n    \n\"derelict-glfw3\"\n:\n \n\"~>4.0.0-beta\"\n\n\n}\n,\n\n\n\"versions\"\n:\n \n[\n\"DerelictGLFW3_Static\"\n]\n,\n\n\n\"libs-windows\"\n:\n \n{\n\n    \n\"glfw3dll\"\n\n\n}\n,\n\n\n\"libs-posix\"\n:\n \n{\n\n    \n\"glfw3\"\n\n\n}\n\n\n\n\n\n\ndub.sdl\n\n\ndependency \n\"derelict-glfw3\"\n \n\"~>4.0.0-beta\"\n\nversions \n\"DerelictGLFW3_Static\"\n\nlibs \n\"glfw3dll\"\n \nplatform\n=\n\"windows\"\n\nlibs \n\"glfw3\"\n \nplatform\n=\n\"posix\"\n\n\n\n\n\n\nLoading the GLFW library\n\u00b6\n\n\nWhen using the static binding configuration, you must link with either the static or dynamic library at link-time. In that case, all GLFW functions can be called directly and nothing special need be done at runtime to use them. \n\n\nWhen using the dynamic binding configuration, the functions must be loaded at runtime via a call to \nDerelictGLFW3.load\n, as shown in the following example.\n\n\nimport\n \nderelict\n.\nglfw3\n;\n\n\nvoid\n \nmain\n()\n \n{\n\n    \nDerelictGLFW3\n.\nload\n();\n\n\n}",
            "title": "DerelictGLFW3"
        },
        {
            "location": "/packages/glfw3/#releases",
            "text": "The DUB package name of DerelictGLFW3 is  derelict-glfw3 .  The current DUB package version is  ~>4.0.0-beta .  The following table shows the correlation between DerelictGLFW3 releases (the most recent patch release of each  major.minor  series), its corresponding git branch, GLFW versions, and DerelictUtil versions. The latest release is listed at the top and is the recommended version. When using DerelictGLFW3 with other Derelict packages, please ensure all of the Derelict packages use the same DerelictUtil  major.minor  series.     DerelictGLFW3 Version  git Branch  GLFW Version  DerelictUtil Version  Supported      4.0.0-beta.1  master / 4.0  3.2.x  3.0.x  \u2714    3.1.3  3.2  3.2.x  2.0.x  \u2714 (bugfix only)    3.0.1  3.1  3.2.x  2.0.x  \u2716    2.0.0  3.0  3.1.x  2.0.x  \u2716    1.1.1  n/a  3.1.x  1.0.x  \u2716    1.0.2  n/a  3.0.x  1.0.x  \u2716     All new development happens on the master branch. Pull requests and issues reported on unsupported branches will be ignored. Both the 4.0.x series and the 3.1.x series support the static binding configuration, but the 3.1.x series should be preferred only for compatibility with other Derelict packages that require DerelictUtil 2.0.x.",
            "title": "Releases"
        },
        {
            "location": "/packages/glfw3/#using-derelictglfw3",
            "text": "See the generic documentation on [Compiling and Linuking] for generic information on incorporating any Derelict package in your project.",
            "title": "Using DerelictGLFW3"
        },
        {
            "location": "/packages/glfw3/#obtaining-the-glfw-binaries",
            "text": "Precompiled binaries for Windows can be downloaded from the  GLFW download page . The zip archive contains binaries for MinGW, and Visual Studio 2012, 2013, and 2015. When using the dynamic binding configuration, any of the DLLs from this archive can be loaded at runtime. When using the static binding configuration, only the Visual Studio binaries should be used. To link statically, use  glfw3.lib . To link dynamically, use  glfw3dll.lib  and distribute the corresponding DLL with your executable. See the documentation on  Windows-specific compilation  for more details.  Windows binaries for Visual Studio are also available via  NuGet  and  vcpkg .  Binaries Mac OS X can be obtained through  Homebrew  or  MacPorts , though they may not always be the latest release.  Binaries for other systems can be obtained through the system package manager.  The GLFW source can be downloaded from the download page or cloned from the  GLFW GitHub repository .",
            "title": "Obtaining the GLFW binaries"
        },
        {
            "location": "/packages/glfw3/#choosing-the-configuration",
            "text": "By default, DerelictGLFW3 will be configured as a dynamic binding. There are two ways to enable the static binding configuration. The recommended way is to add a  subConfiguration  entry to your project configuration with the value  derelict-glfw3-static  and the appropriate library, as in the following examples. Note that the example assumes linking dynamically, using the precompiled binaries from the GLFW website on Windows. In other binary distributions on Windows, the dynamic import library may simply be named  glfw3.lib  instead. In that case, a single  libs  entry with no platform suffix will suffice.    dub.json  \"dependencies\" :   { \n     \"derelict-glfw3\" :   \"~>4.0.0-beta\"  } ,  \"subConfigurations\" :   { \n     \"derelict-glfw3\" :   \"derelict-glfw3-static\"  } ,  \"libs-windows\" :   { \n     \"glfw3dll\"  } ,  \"libs-posix\" :   { \n     \"glfw3\"  }   dub.sdl  dependency  \"derelict-glfw3\"   \"~>4.0.0-beta\" \nsubConfiguration  \"derelict-glfw3\"   \"derelict-glfw3-static\" \nlibs  \"glfw3dll\"   platform = \"windows\" \nlibs  \"glfw3\"   platform = \"posix\"   The alternative is to replace the  subConfiguration  with a  versions  entry and give it one of two values, either  Derelict_Static  or  DerelictGLFW3_Static . The former will enable the static binding configuration of any other Derelict packages in your project that support it. The latter will enable it only for DerelictGLFW3.  dub.json  \"dependencies\" :   { \n     \"derelict-glfw3\" :   \"~>4.0.0-beta\"  } ,  \"versions\" :   [ \"DerelictGLFW3_Static\" ] ,  \"libs-windows\" :   { \n     \"glfw3dll\"  } ,  \"libs-posix\" :   { \n     \"glfw3\"  }   dub.sdl  dependency  \"derelict-glfw3\"   \"~>4.0.0-beta\" \nversions  \"DerelictGLFW3_Static\" \nlibs  \"glfw3dll\"   platform = \"windows\" \nlibs  \"glfw3\"   platform = \"posix\"",
            "title": "Choosing the configuration"
        },
        {
            "location": "/packages/glfw3/#loading-the-glfw-library",
            "text": "When using the static binding configuration, you must link with either the static or dynamic library at link-time. In that case, all GLFW functions can be called directly and nothing special need be done at runtime to use them.   When using the dynamic binding configuration, the functions must be loaded at runtime via a call to  DerelictGLFW3.load , as shown in the following example.  import   derelict . glfw3 ;  void   main ()   { \n     DerelictGLFW3 . load ();  }",
            "title": "Loading the GLFW library"
        },
        {
            "location": "/packages/sdl2/",
            "text": "DerelictSDL2 provides both \nstatic and dynamic bindings\n the 2.x series of the \nSDL (Simple Direct Media Layer)\n library. DerelictSDL2 3.0.0 and higher supports all releases of SDL2 from version 2.0.0 to version 2.0.5 via Derelict's \nSharedLibVersion\n feature. The package also includes bindings to the following SDL satellite libraries:\n\n\n\n\nSDL_image\n\n\nSDL_mixer\n\n\nSDL_net\n\n\nSDL_ttf\n\n\n\n\nReleases\n\u00b6\n\n\nThe DUB package name of DerelictSDL2 is \nderelict-sdl2\n.\n\n\nThe current DUB package version is \n~>3.0.0-beta\n.\n\n\nThe following table shows the correlation between DerelictSDL2 releases (the most recent patch release of each \nmajor.minor\n series), its corresponding git branch, GLFW versions, and DerelictUtil versions. The latest release is listed at the top and is the recommended version. When using DerelictSDL2 with other Derelict packages, please ensure all of the Derelict packages use the same DerelictUtil \nmajor.minor\n series.\n\n\n\n\n\n\n\n\nDerelictSDL2 Version\n\n\ngit Branch\n\n\nSDL  Version\n\n\nDerelictUtil Version\n\n\nSupported\n\n\n\n\n\n\n\n\n\n\n3.0.0-beta.2\n\n\nmaster\n/\n3.0\n\n\n2.0.0 - 2.0.5\n\n\n3.0.x\n\n\n\u2714\n\n\n\n\n\n\n2.1.4\n\n\n2.1\n\n\n2.0.0 - 2.0.4\n\n\n2.0.x\n\n\n\u2714 (bugfix only)\n\n\n\n\n\n\n2.0.2\n\n\n[2.0.2]\n\n\n2.0.0 - 2.0.4\n\n\n2.0.x\n\n\n\u2716\n\n\n\n\n\n\n1.9.7\n\n\nn/a\n\n\n2.0.2 - 2.0.3\n\n\n2.0.x\n\n\n\u2716\n\n\n\n\n\n\n1.2.16\n\n\nn/a\n\n\n2.0.2 - 2.0.3\n\n\n1.0.x\n\n\n\u2716\n\n\n\n\n\n\n1.1.17\n\n\nn/a\n\n\n2.0.0\n\n\n1.0.x\n\n\n\u2716\n\n\n\n\n\n\n\n\nAll new development happens on the master branch. Pull requests and issues reported on unsupported branches will be ignored. Only the 3.0.x series supports the static binding configuration. The 2.1.x series should be preferred only for compatibility with other Derelict packages that require DerelictUtil 2.0.x.\n\n\n[2.0.2] https://github.com/DerelictOrg/DerelictSDL2/tree/2.0.2\n\n\nUsing DerelictSDL2\n\u00b6\n\n\nSee the generic documentation on [Compiling and Linuking] for generic information on incorporating any Derelict package in your project.\n\n\nObtaining the SDL binaries\n\u00b6\n\n\nPrecompiled binaries for Windows and Mac OS X can be downloaded from the the following pages:\n\n\n\n\nSDL2\n\n\nSDL_image\n\n\nSDL_mixer\n\n\nSDL_net\n\n\nSDL_ttf\n\n\n\n\nFor the dynamic binding configuration, either the Runtime Binaries or the Development Libraries will suffice. They all contain the shared libraries. For the static binding configuration, the Development Libraries should be used, the Visual C++ version on Windows (see the page on \nWindows-specific compilation\n for more information).\n\n\nWindows binaries for Visual Studio are also available via \nNuGet\n and \nvcpkg\n.\n\n\nBinaries Mac OS X can be obtained through \nHomebrew\n or \nMacPorts\n.\n\n\nBinaries for other systems can be obtained through the system package manager.\n\n\nThe SDL source can be downloaded from the download page or cloned from the \nSDL mercurial repository\n.\n\n\nChoosing the configuration\n\u00b6\n\n\nBy default, DerelictSDL2 will be configured as a dynamic binding. There are two ways to enable the static binding configuration. The recommended way is to add a \nsubConfiguration\n entry to your project configuration with the value \nderelict-sdl2-static\n and the appropriate library, as in the following examples. \n\n\ndub.json\n\n\n\"dependencies\"\n:\n \n{\n\n    \n\"derelict-sdl2\"\n:\n \n\"~>3.0.0-beta\"\n\n\n}\n,\n\n\n\"subConfigurations\"\n:\n \n{\n\n    \n\"derelict-sdl2\"\n:\n \n\"derelict-sdl2-static\"\n\n\n}\n,\n\n\n\"libs\"\n:\n \n{\n\n    \n\"sdl2\"\n\n\n}\n,\n\n\n\n\n\n\ndub.sdl\n\n\ndependency \n\"derelict-sdl2\"\n \n\"~>3.0.0-beta\"\n\nsubConfiguration \n\"derelict-sdl2\"\n \n\"derelict-sdl2-static\"\n\nlibs \n\"sdl2\"\n\n\n\n\n\n\nThe alternative is to replace the \nsubConfiguration\n with a \nversions\n entry and give it one of two values, either \nDerelict_Static\n or \nDerelictSDL2_Static\n. The former will enable the static binding configuration of any other Derelict packages in your project that support it. The latter will enable it only for DerelictSDL2.\n\n\ndub.json\n\n\n\"dependencies\"\n:\n \n{\n\n    \n\"derelict-sdl2\"\n:\n \n\"~>3.0.0-beta\"\n\n\n}\n,\n\n\n\"versions\"\n:\n \n[\n\"DerelictSDL2_Static\"\n]\n,\n\n\n\"libs\"\n:\n \n{\n\n    \n\"sdl2\"\n\n\n}\n\n\n\n\n\n\ndub.sdl\n\n\ndependency \n\"derelict-sdl2\"\n \n\"~>3.0.0-beta\"\n\nversions \n\"DerelictSDL2_Static\"\n\nlibs \n\"sdl2dll\"\n \nplatform\n=\n\"windows\"\n\nlibs \n\"sdl2\"\n \nplatform\n=\n\"posix\"\n\n\n\n\n\n\nLoading the SDL libraries\n\u00b6\n\n\nWhen using the static binding configuration, you must link with either the static or dynamic libraries at link-time. In that case, all SDL functions can be called directly and nothing special need be done at runtime to use them. \n\n\nWhen using the dynamic binding configuration, the functions must be loaded at runtime via a call to the appropriate loader, such as \nDerelictSDL2.load\n, as shown in the following example.\n\n\nimport\n \nderelict\n.\nsdl2\n.\nsdl\n;\n\n\nvoid\n \nmain\n()\n \n{\n\n    \nDerelictSDL2\n.\nload\n();\n\n\n}\n\n\n\n\n\n\nEach of the satellite libraries has its own module and its own loader:\n\n\nimport\n \nderelict\n.\nsdl2\n.\nimage\n,\n\n       \nderelict\n.\nsdl2\n.\nsdl\n;\n\n\nvoid\n \nmain\n()\n \n{\n\n    \nDerelictSDL2\n.\nload\n();\n\n    \nDerelictSDL2Image\n.\nload\n();\n\n\n}\n\n\n\n\n\n\nAll of the loaders and bindings in the DerelictSDL2 package can be imported at once via \nimport derelict.sdl2\n.\n\n\nSharedLibVersion\n\u00b6\n\n\nSince version \n2.0.2\n, the DerelictSDL2 loader (but none of the satellite loaders) has supported loading the shared library with the \nSharedLibVersion\n structure (see the table at the top of the page to see which versions are available in each release). By default, the loader attempts to load the highest supported version of SDL and will fail if that version is unavailable. By using \nSharedLibVersion\n, you can specify a minimum required version of SDL. All higher versions will still load, but all lower versions will fail. For example:\n\n\nimport\n \nderelict\n.\nsdl2\n.\nsdl\n;\n\n\nimport\n \nderelict\n.\nutil\n.\nloader\n \n:\n \nSharedLibVersion\n;\n\n\n\nvoid\n \nmain\n()\n \n{\n\n    \nDerelictSDL2\n.\nload\n(\nSharedLibVersion\n(\n2\n,\n \n0\n,\n \n2\n));\n\n\n}\n\n\n\n\n\n\n\n\nNote\n\n\nIf you want to use SDL 2.0.1 as a minimum version to take advantage of the [file system API] that was not available in 2.0.0, then be aware that there was a bug in version 2.0.1 on Windows that prevented the preference path from being created on the user's system. The bug was fixed in SDL 2.0.2. In this case, the following code will do the right thing:\n\n\n\n\nimport\n \nderelict\n.\nsdl2\n.\nsdl\n;\n\n\nimport\n \nderelict\n.\nutil\n.\nloader\n \n:\n \nSharedLibVersion\n;\n\n\n\nvoid\n \nmain\n()\n \n{\n\n    \n// Require 2.0.2 on Windows because of the pref path bug in 2.0.1\n\n    \nversion\n(\nWindows\n)\n \nDerelictSDL2\n.\nload\n(\nSharedLibVersion\n(\n2\n,\n \n0\n,\n \n2\n));\n\n    \nelse\n \nDerelictSDL2\n.\nload\n(\nSharedLibVersion\n(\n2\n,\n \n0\n,\n \n1\n));\n\n\n}\n\n\n\n\n\n\nSee the loader documentation for more info.",
            "title": "DerelictSDL2"
        },
        {
            "location": "/packages/sdl2/#releases",
            "text": "The DUB package name of DerelictSDL2 is  derelict-sdl2 .  The current DUB package version is  ~>3.0.0-beta .  The following table shows the correlation between DerelictSDL2 releases (the most recent patch release of each  major.minor  series), its corresponding git branch, GLFW versions, and DerelictUtil versions. The latest release is listed at the top and is the recommended version. When using DerelictSDL2 with other Derelict packages, please ensure all of the Derelict packages use the same DerelictUtil  major.minor  series.     DerelictSDL2 Version  git Branch  SDL  Version  DerelictUtil Version  Supported      3.0.0-beta.2  master / 3.0  2.0.0 - 2.0.5  3.0.x  \u2714    2.1.4  2.1  2.0.0 - 2.0.4  2.0.x  \u2714 (bugfix only)    2.0.2  [2.0.2]  2.0.0 - 2.0.4  2.0.x  \u2716    1.9.7  n/a  2.0.2 - 2.0.3  2.0.x  \u2716    1.2.16  n/a  2.0.2 - 2.0.3  1.0.x  \u2716    1.1.17  n/a  2.0.0  1.0.x  \u2716     All new development happens on the master branch. Pull requests and issues reported on unsupported branches will be ignored. Only the 3.0.x series supports the static binding configuration. The 2.1.x series should be preferred only for compatibility with other Derelict packages that require DerelictUtil 2.0.x.  [2.0.2] https://github.com/DerelictOrg/DerelictSDL2/tree/2.0.2",
            "title": "Releases"
        },
        {
            "location": "/packages/sdl2/#using-derelictsdl2",
            "text": "See the generic documentation on [Compiling and Linuking] for generic information on incorporating any Derelict package in your project.",
            "title": "Using DerelictSDL2"
        },
        {
            "location": "/packages/sdl2/#obtaining-the-sdl-binaries",
            "text": "Precompiled binaries for Windows and Mac OS X can be downloaded from the the following pages:   SDL2  SDL_image  SDL_mixer  SDL_net  SDL_ttf   For the dynamic binding configuration, either the Runtime Binaries or the Development Libraries will suffice. They all contain the shared libraries. For the static binding configuration, the Development Libraries should be used, the Visual C++ version on Windows (see the page on  Windows-specific compilation  for more information).  Windows binaries for Visual Studio are also available via  NuGet  and  vcpkg .  Binaries Mac OS X can be obtained through  Homebrew  or  MacPorts .  Binaries for other systems can be obtained through the system package manager.  The SDL source can be downloaded from the download page or cloned from the  SDL mercurial repository .",
            "title": "Obtaining the SDL binaries"
        },
        {
            "location": "/packages/sdl2/#choosing-the-configuration",
            "text": "By default, DerelictSDL2 will be configured as a dynamic binding. There are two ways to enable the static binding configuration. The recommended way is to add a  subConfiguration  entry to your project configuration with the value  derelict-sdl2-static  and the appropriate library, as in the following examples.   dub.json  \"dependencies\" :   { \n     \"derelict-sdl2\" :   \"~>3.0.0-beta\"  } ,  \"subConfigurations\" :   { \n     \"derelict-sdl2\" :   \"derelict-sdl2-static\"  } ,  \"libs\" :   { \n     \"sdl2\"  } ,   dub.sdl  dependency  \"derelict-sdl2\"   \"~>3.0.0-beta\" \nsubConfiguration  \"derelict-sdl2\"   \"derelict-sdl2-static\" \nlibs  \"sdl2\"   The alternative is to replace the  subConfiguration  with a  versions  entry and give it one of two values, either  Derelict_Static  or  DerelictSDL2_Static . The former will enable the static binding configuration of any other Derelict packages in your project that support it. The latter will enable it only for DerelictSDL2.  dub.json  \"dependencies\" :   { \n     \"derelict-sdl2\" :   \"~>3.0.0-beta\"  } ,  \"versions\" :   [ \"DerelictSDL2_Static\" ] ,  \"libs\" :   { \n     \"sdl2\"  }   dub.sdl  dependency  \"derelict-sdl2\"   \"~>3.0.0-beta\" \nversions  \"DerelictSDL2_Static\" \nlibs  \"sdl2dll\"   platform = \"windows\" \nlibs  \"sdl2\"   platform = \"posix\"",
            "title": "Choosing the configuration"
        },
        {
            "location": "/packages/sdl2/#loading-the-sdl-libraries",
            "text": "When using the static binding configuration, you must link with either the static or dynamic libraries at link-time. In that case, all SDL functions can be called directly and nothing special need be done at runtime to use them.   When using the dynamic binding configuration, the functions must be loaded at runtime via a call to the appropriate loader, such as  DerelictSDL2.load , as shown in the following example.  import   derelict . sdl2 . sdl ;  void   main ()   { \n     DerelictSDL2 . load ();  }   Each of the satellite libraries has its own module and its own loader:  import   derelict . sdl2 . image , \n        derelict . sdl2 . sdl ;  void   main ()   { \n     DerelictSDL2 . load (); \n     DerelictSDL2Image . load ();  }   All of the loaders and bindings in the DerelictSDL2 package can be imported at once via  import derelict.sdl2 .",
            "title": "Loading the SDL libraries"
        },
        {
            "location": "/packages/sdl2/#sharedlibversion",
            "text": "Since version  2.0.2 , the DerelictSDL2 loader (but none of the satellite loaders) has supported loading the shared library with the  SharedLibVersion  structure (see the table at the top of the page to see which versions are available in each release). By default, the loader attempts to load the highest supported version of SDL and will fail if that version is unavailable. By using  SharedLibVersion , you can specify a minimum required version of SDL. All higher versions will still load, but all lower versions will fail. For example:  import   derelict . sdl2 . sdl ;  import   derelict . util . loader   :   SharedLibVersion ;  void   main ()   { \n     DerelictSDL2 . load ( SharedLibVersion ( 2 ,   0 ,   2 ));  }    Note  If you want to use SDL 2.0.1 as a minimum version to take advantage of the [file system API] that was not available in 2.0.0, then be aware that there was a bug in version 2.0.1 on Windows that prevented the preference path from being created on the user's system. The bug was fixed in SDL 2.0.2. In this case, the following code will do the right thing:   import   derelict . sdl2 . sdl ;  import   derelict . util . loader   :   SharedLibVersion ;  void   main ()   { \n     // Require 2.0.2 on Windows because of the pref path bug in 2.0.1 \n     version ( Windows )   DerelictSDL2 . load ( SharedLibVersion ( 2 ,   0 ,   2 )); \n     else   DerelictSDL2 . load ( SharedLibVersion ( 2 ,   0 ,   1 ));  }   See the loader documentation for more info.",
            "title": "SharedLibVersion"
        },
        {
            "location": "/packages/sfml2/",
            "text": "Yeah, yeah. I'm getting there. Patience, please.",
            "title": "DerelictSFML2"
        }
    ]
}